// generated by generate.py; DO NOT EDIT
package pansi

const (
	Invalid                       AnsiEscapeType = iota
	CBT, CursorBackwardTabulation AnsiEscapeType = iota, iota
	//Cursor Backward Tabulation (CBT)
	//Move the active position n tabs backward.
	//
	//The active position is moved to the character position corresponding to the n-th
	//preceding horizontal tabulation stop. If an attempt is made to move the active
	//position past the first character position on the line, then the active position stays
	//at column one.
	//
	//Format:
	//	CSI Pn Z
	//	9B  3n 5A
	//
	//Parameters:
	//	Pn- is the number of active position tabs to move backward.
	//
	//Default: 1

	CHA, CursorHorizontalAbsolute AnsiEscapeType = iota, iota
	//Cursor Horizontal Absolute (CHA)
	//Move the active position to the n-th character of the active line.
	//
	//The active position is moved to the n-th character position of the active line.
	//
	//Format:
	//	CSI Pn G
	//	9B  3n 47
	//
	//Parameters:
	//	Pn- is the number of active positions to the n-th character of the active line.
	//
	//Default: 1

	CHT, CursorHorizontalForwardTabulation AnsiEscapeType = iota, iota
	//Cursor Horizontal Forward Tabulation (CHT)
	//Move the active position n tabs forward.
	//
	//The active position is moved to the character position corresponding to the
	//following n-th horizontal tabulation stop.
	//
	//Format:
	//	CSI Pn I
	//	9B  3n 49
	//
	//Parameters:
	//	Pn- is the number of active position tabs to move forward.
	//
	//Default: 1

	CNL, CursorNextLine AnsiEscapeType = iota, iota
	//Cursor Next Line (CNL)
	//Move the cursor to the next line.
	//
	//The active position is moved to the first character of the n-th following line.
	//
	//Format:
	//	CSI Pn E
	//	9B  3n 45
	//
	//Parameters:
	//	Pn- is the active position to the first character of the n-th following line.
	//
	//Default: 1

	CPL, CursorPreviousLine AnsiEscapeType = iota, iota
	//Cursor Previous Line (CPL)
	//Move the cursor to the preceding line.
	//
	//The active position is moved to the first character of the n-th preceding line.
	//
	//Format:
	//	CSI Pn F
	//	9B  3n 46
	//
	//Parameters:
	//	Pn- is the number of active position moved to the first character of the n-th preceding
	//line.
	//
	//Default: 1

	CPR, CursorPositionReport AnsiEscapeType = iota, iota
	//Cursor Position Report (CPR)
	//The host asks the terminal for a cursor position report.
	//
	//
	//
	//Format:
	//	CSI 6  n
	//	9B  36 6E
	//	CSI Pl ;  Pc R
	//	9B  3n 3B 3n 52
	//

	CRM, ShowControlCharacterMode AnsiEscapeType = iota, iota
	//Show Control Character Mode (CRM)
	//Enable or disable control characters to be displayed.
	//
	//When CRM mode is set, all characters (graphic or control) are displayed in the
	//CRM font. All control functions are displayed as graphic characters. No control
	//functions are executed, except LF, FF, and VT, which are represented in the CRM
	//font before a CRLF (new line) is executed. XOFF (DC3) and XON (DC1) are used
	//for flow control (if enabled). DC1 and DC3 are displayed after execution.
	//
	//This function affects data received in the data stream following the change to
	//CRM mode. Characters already displayed are not affected. Entering Control
	//Representation mode temporarily causes G0 and GL to be loaded with ASCII. G2
	//and GR are loaded with user-selected Supplemental Graphic characters if in 8-bit
	//Multinational Character mode.
	//
	//Notes on CRM
	//
	//
	//CRM mode works in all VT terminal modes.
	//NUL is displayed and is not useful as a fill character.
	//CRM mode overrides Printer Controller mode. When in CRM, Printer
	//Controller mode is temporarily off.
	//In local mode and CRM (or local echo and CRM), CSI sequences may be
	//represented as either ESC Fe sequences (such as ESC [) or as C1 controls.
	//Conversely, C1 controls may be represented as either C1 controls or as ESC
	//Fe sequences.
	//In CRM mode, auto-wrap always occurs at the right margin. Sending a
	//sequence or disabling auto-wrap in Set-Up is ignored.
	//Terminal Device Protocol commands are not affected if Control Representation
	//mode is entered.
	//
	//
	//Format:
	//	CSI 3  h
	//	9B  33 68
	//	CSI 3  l
	//	9B  33 6C
	//

	CUB, CursorBackward AnsiEscapeType = iota, iota
	//Cursor Backward (CUB)
	//This control function moves the cursor to the left by a specified number of
	//columns. The cursor stops at the left border of the page.
	//
	//
	//
	//Format:
	//	CSI Pn D
	//	9B  3n 44
	//

	CUD, CursorDown AnsiEscapeType = iota, iota
	//Cursor Down (CUD)
	//This control function moves the cursor down a specified number of lines in the
	//same column. The cursor stops at the bottom margin. If the cursor is already
	//below the bottom margin, then the cursor stops at the bottom line.
	//
	//
	//
	//Format:
	//	CSI Pn B
	//	9B  3n 42
	//

	CUF, CursorForward AnsiEscapeType = iota, iota
	//Cursor Forward (CUF)
	//This control function moves the cursor to the right by a specified number of
	//columns. The cursor stops at the right border of the page.
	//
	//
	//
	//Format:
	//	CSI Pn C
	//	9B  3n 43
	//

	CUP, CursorPosition AnsiEscapeType = iota, iota
	//Cursor Position (CUP)
	//This control function moves the cursor to the specified line and column. The
	//starting point for lines and columns depends on the setting of origin mode
	//(DECOM). CUP applies only to the current page.
	//
	//
	//
	//Format:
	//	CSI Pl ;  Pc H
	//	9B  3n 3B 3n 48
	//

	CUU, CursorUp AnsiEscapeType = iota, iota
	//Cursor Up (CUU)
	//Moves the cursor up a specified number of lines in the same column. The cursor
	//stops at the top margin. If the cursor is already above the top margin, then the
	//cursor stops at the top line.
	//
	//
	//
	//Format:
	//	CSI Pn A
	//	9B  3n 41
	//

	DA1, PrimaryDeviceAttributes AnsiEscapeType = iota, iota
	//Primary Device Attributes (DA1)
	//In this DA exchange, the host asks for the terminal's architectural class and basic
	//attributes.
	//
	//
	//
	//Format:
	//	CSI c
	//	9B  63
	//	CSI 0  c  CSI ?  6  4  ;  Ps1 ;  ... Psn c  CSI ?  6  4  ;  Ps1 ;  ... Psn c
	//	9B  30 63 9B  3F 36 34 3B 3n  3B ... 3n  63 9B  3F 36 34 3B 3n  3B ... 3n  63
	//
	//Parameters:
	//	Ps1 ; . . . Psn- reports different device attributes between the North American terminal and the
	//international terminal.	The terminal responds by sending its architectural class and basic attributes to- the host. This response depends on the terminal's current operating VT level.	1- 	The value of the first parameter is encoded so a simple range check can be- performed to determine the basic service class and level of the device. The VT510
	//is a level 4 terminal so its service class code is 64. The following extensions to
	//level 4 are provided:

	DA2, SecondaryDeviceAttributes AnsiEscapeType = iota, iota
	//Secondary Device Attributes (DA2)
	//In this DA exchange, the host requests the terminal's identification code,
	//firmware version level, and hardware options.
	//
	//
	//
	//Format:
	//	CSI &gt; c
	//	9B  3E   63
	//	CSI &gt; 0  c  CSI &gt; 6  1  ;  Pv ;  0  c
	//	9B  3E   30 63 9B  3E   36 31 3B 3n 3B 30 63
	//	CSI &gt; 6  1  ;  Pv ;  1  c
	//	9B  3E   36 31 3B 3n 3B 31 63
	//
	//Parameters:
	//	61- indicates the identification code of the terminal for the secondary device attributes
	//command.	Pv- indicates the version level of the firmware implementing the terminal
	//management functions, for example, editing, as shown in the following table.	0- The terminal with a VT keyboard uses the following sequence to respond:

	DA3, TertiaryDeviceAttributes AnsiEscapeType = iota, iota
	//Tertiary Device Attributes (DA3)
	//In this DA exchange, the host asks for the terminal unit identification code. This
	//ID code serves as a way to identify each terminal in a system. The unit ID code
	//is preset at the factory.
	//
	//
	//
	//Format:
	//	CSI =  c
	//	9B  3D 63
	//	CSI =  0  c  DCS !  |  D . . . D ST
	//	9B  3D 30 63 90  21 7C ...       9C
	//
	//Parameters:
	//	The last three hexadecimal pairs are the terminal ID number. This number is- unique for each terminal manufactured at that site.	The terminal responds by sending a report terminal unit ID (DECRPTUI) control- string to the host. DECRPTUI is available in VT Level 4 mode only.	D...D- is the unit ID of the terminal, consisting of four hexadecimal pairs. The first pair
	//represents the manufacturing site code. This code can be any hexadecimal value
	//from 00 through FF.

	DCH, DeleteCharacter AnsiEscapeType = iota, iota
	//Delete Character (DCH)
	//This control function deletes one or more characters from the cursor position to
	//the right.
	//
	//As characters are deleted, the remaining characters between the cursor and
	//right margin move to the left. Character attributes move with the characters.
	//The terminal adds blank spaces with no visual character attributes at the right
	//margin. DCH has no effect outside the scrolling margins.
	//
	//Format:
	//	CSI Pn P
	//	9B  3n 50
	//
	//Parameters:
	//	0- Default: Pn = 1.

	DECAAM, SetResetAutoAnswerbackMode AnsiEscapeType = iota, iota
	//Set/Reset Auto Answerback Mode (DECAAM)
	//Selects whether the terminal automatically sends (enables) or does not send
	//(disables) the answerback message to the host computer after a communication
	//line connection.
	//
	//When modem control is enabled, the answerback message is sent 500 ms after
	//the connection is made.
	//
	//Format:
	//	CSI ?  1  0  0  h
	//	9B  3F 31 30 30 68
	//	CSI ?  1  0  0  l
	//	9B  3F 31 30 30 6C
	//

	DECALN, ScreenAlignmentPattern AnsiEscapeType = iota, iota
	//Screen Alignment Pattern (DECALN)
	//This control function fills the complete screen area with a test pattern used for
	//adjusting screen alignment. Normally, only manufacturing and service personnel
	//would use DECALN.
	//
	//
	//
	//Format:
	//	ESC #  8
	//	1B  23 38
	//

	DECANM, ANSIMode AnsiEscapeType = iota, iota
	//ANSI Mode (DECANM)
	//DECANM changes the terminal to the VT52 mode of operation. In VT52 mode,
	//the terminal acts like a VT52 terminal. This mode lets you use applications
	//designed for the VT52 terminal.
	//
	//
	//Table 5&#8211;1 VT52 Escape Sequences
	//
	//
	//
	//
	//Sequence
	//Action
	//
	//
	//
	//
	//ESC A
	//Cursor up.
	//
	//
	//ESC B
	//Cursor down.
	//
	//
	//ESC C
	//Cursor right.
	//
	//
	//ESC D
	//Cursor left.
	//
	//
	//ESC F
	//Enter graphics mode.
	//
	//
	//ESC G
	//Exit graphics mode.
	//
	//
	//ESC H
	//Cursor to home position.
	//
	//
	//ESC I
	//Reverse line feed.
	//
	//
	//ESC J
	//Erase from cursor to end of screen.
	//
	//
	//ESC K
	//Erase from cursor to end of line.
	//
	//
	//ESC Y Pn
	//Move cursor to column Pn.
	//
	//
	//ESC Z
	//Identify (host to terminal).
	//
	//
	//ESC /Z
	//Report (terminal to host).
	//
	//
	//ESC =
	//Enter alternate keypad mode.
	//
	//
	//ESC &gt;
	//Exit alternate keypad mode.
	//
	//
	//ESC &lt;
	//Exit VT52 mode. Enter VT100 mode.
	//
	//
	//ESC ^
	//Enter autoprint mode.
	//
	//
	//ESC _
	//Exit autoprint mode.
	//
	//
	//ESC W
	//Enter printer controller mode.
	//
	//
	//ESC X
	//Exit printer controller mode.
	//
	//
	//ESC ]
	//Print screen.
	//
	//
	//ESC V
	//Print the line with the cursor.
	//
	//
	//
	//
	//Format:
	//	CSI ?  2  l
	//	9B  3F 32 6C
	//

	DECARM, AutorepeatMode AnsiEscapeType = iota, iota
	//Autorepeat Mode (DECARM)
	//This control function determines whether or not keys automatically repeat their
	//character when held down. If DECARM is set, then most keys you press for more
	//than 0.5 seconds send a character repeatedly until you release the key.
	//
	//
	//
	//Format:
	//	CSI ?  8  h
	//	9B  3F 38 68
	//	CSI ?  8  l
	//	9B  3F 38 6C
	//

	DECARSM, SetResetAutoResizeMode AnsiEscapeType = iota, iota
	//Set/Reset Auto Resize Mode (DECARSM)
	//Enable or disable changing the lines per screen automatically when the page
	//arrangement changes.
	//
	//When Auto Resize is enabled, the number of Lines/Screen changes automatically
	//each time the page arrangement changes.
	//
	//Auto Resize and Number of lines per screen are user features that can be
	//locked from being redefined by the host if the User Feature Lock in Set-Up is
	//enabled.
	//
	//The following table indicates how the lines/screen changes when the page size
	//changes, assuming Auto Resize is set.
	//
	//
	//
	//
	//
	//
	//Page size
	//Lines/Screen
	//
	//
	//
	//
	//24
	//26 (24 data lines, 1 status line, 1 blank line)
	//
	//
	//25
	//26 (25 data lines, 1 status line)
	//
	//
	//36
	//42 (36 data lines, 1 status line, 5 blank lines)
	//
	//
	//41
	//42 (41 data lines, 1 status line)
	//
	//
	//42
	//42 (42 data lines, no status line)
	//
	//
	//48
	//53 (48 data lines, 1 status line, 4 blank lines)
	//
	//
	//52
	//53 (52 data lines, 1 status line)
	//
	//
	//53
	//53 (53 data lines, 0 status line)
	//
	//
	//72
	//53 (53 data lines, 0 status line)
	//
	//
	//
	//
	//Format:
	//	CSI ?  9  8  h
	//	9B  3F 39 38 68
	//	CSI ?  9  8  l
	//	9B  3F 39 38 6C
	//

	DECAUPSS, AssigningUserPreferredSupplementalSets AnsiEscapeType = iota, iota
	//Assigning User-Preferred Supplemental Sets (DECAUPSS)
	//You can assign the supplemental character set you use most often as a special
	//standby set. This standby set is called the user-preferred supplemental set. This
	//feature provides applications with an easy way to access the user's preferred
	//supplemental set.
	//
	//You can assign any supplemental or ISO Latin supplemental set as the standby
	//set. See SCS&#8212;Select Character Set for more information.
	//
	//After you assign a set:
	//
	//
	//Designate the set as G1, G2, or G3.
	//Map the set into GR.
	//
	//
	//Format:
	//	DCS Pn !  u  Dscs ST
	//	90  3n 21 75 3n   9C
	//
	//Parameters:
	//	Pn- represents a character set designator.	Dscs- represents a character set.	You can assign any supplemental or ISO Latin supplemental set as the standby- set. See SCS&#8212;Select Character Set for more information.
	//
	//Default: DEC Supplemental Graphic

	DECAWM, AutowrapMode AnsiEscapeType = iota, iota
	//Autowrap Mode (DECAWM)
	//This control function determines whether or not received characters automatically
	//wrap to the next line when the cursor reaches the right border of a page in page
	//memory.
	//
	//If the DECAWM function is set, then graphic characters received when the cursor
	//is at the right border of the page appear at the beginning of the next line. Any
	//text on the page scrolls up if the cursor is at the end of the scrolling region.
	//
	//If the DECAWM function is reset, then graphic characters received when the
	//cursor is at the right border of the page replace characters already on the page.
	//
	//Format:
	//	CSI ?  7  h
	//	9B  3F 37 68
	//	CSI ?  7  l
	//	9B  3F 37 6C
	//

	DECBI, BackIndex AnsiEscapeType = iota, iota
	//Back Index (DECBI)
	//This control function moves the cursor backward one column. If the cursor is at
	//the left margin, then all screen data within the margin moves one column to the
	//right. The column that shifted past the right margin is lost.
	//
	//DECBI adds a new column at the left margin with no visual attributes. DECBI
	//is not affected by the margins. If the cursor is at the left border of the page when
	//the terminal receives DECBI, then the terminal ignores DECBI.
	//
	//Format:
	//	ESC 6
	//	1B  36
	//

	DECBKM, BackarrowKeyMode AnsiEscapeType = iota, iota
	//Backarrow Key Mode (DECBKM)
	//This control function determines whether the
	//
	//If DECBKM is set,  works as a backspace key. When you press , the
	//terminal sends a BS character to the host.
	//
	//If DECBKM is reset,  works as a delete key. When you press , the terminal
	//sends a DEL character to the host.
	//
	//Format:
	//	CSI ?  6  7  h
	//	9B  3F 36 37 68
	//	CSI ?  6  7  l
	//	9B  3F 36 37 6C
	//

	DECCANSM, ConcealAnswerbackMessageMode AnsiEscapeType = iota, iota
	//Conceal Answerback Message Mode (DECCANSM)
	//Conceal the answerback message.
	//
	//
	//
	//
	//
	//
	//Setting
	//Function
	//
	//
	//
	//
	//Not concealed
	//The answerback message is visible in Set-Up.
	//
	//
	//Concealed
	//The text "concealed" replaces the answerback
	//message.
	//The answerback message cannot be set back to
	//"not concealed" either through a host control
	//function or Set-Up. Only entering a new
	//message returns this field to "not concealed."
	//If the user or host requests the terminal
	//to reset to the default setting (answerback
	//message not concealed (CSI ? 101 l)) when the
	//answerback message is set to "concealed," then
	//the terminal will not reset the answerback
	//message to "not concealed."
	//
	//
	//
	//
	//Format:
	//	CSI ?  1  0  1  h
	//	9B  3F 31 30 31 68
	//	CSI ?  1  0  1  l
	//	9B  3F 31 30 31 6C
	//

	DECCAPSLK, CapsLockMode AnsiEscapeType = iota, iota
	//Caps Lock Mode (DECCAPSLK)
	//DECCAPSLK controls the state of the
	//
	//
	//
	//Format:
	//	CSI ?  1  0  9  h
	//	9B  3F 31 30 39 68
	//	CSI ?  1  0  9  l
	//	9B  3F 31 30 39 6C
	//

	DECCARA, ChangeAttributesinRectangularArea AnsiEscapeType = iota, iota
	//Change Attributes in Rectangular Area (DECCARA)
	//This control function lets you change the visual character attributes (bold, blink,
	//reverse video, and underline) of a specified rectangular area in page memory. The
	//select attribute change extent (DECSACE) control function determines whether
	//all or some of the character positions in the rectangle are affected. DECCARA
	//does not change the values of characters just the visual attributes of those
	//characters.
	//
	//
	//
	//Format:
	//	CSI Pt; Pl; Pb; Pr;    Ps1; . . . Psn       $  r
	//	9B  area to be changed attributes to change 24 72
	//
	//Parameters:
	//	The following sequence turns off the blinking character attribute from position- line 10, column 2 to position line 14, column 45 on the current page:	Pr- is the right-column border.
	//Default: Pr = last column of the active page.	Ps1; . . . Psn- select the visual character attributes to change. These values correspond to the
	//values used in the select graphic rendition.	Pb- is the bottom-line border.
	//Default: Pb = last line of the active page.	The following sequence changes the video attributes of the complete screen to- blink and underscore:	Pt- is the top-line border. Pt must be less than or equal to Pb.
	//Default: Pt = 1.	Pl- is the left-column border. Pl must be less than or equal to Pr.
	//Default: Pl = 1.	Pt; Pl; Pb; Pr;- define the rectangular area to be changed. A semicolon (3/11) separates
	//parameters.	DECCARA ignores all other parameter values. When you use more than one- parameter in a command, DECCARA executes them cumulatively in sequence.	8- CSI ; ; ; ; 0; 4; 5 $ r

	DECCIR, CursorInformationReportTerminaltoHost AnsiEscapeType = iota, iota
	//Cursor Information Report (Terminal to Host) (DECCIR)
	//The terminal sends this sequence in response to a request presentation state
	//report (DECRQPSR) sequence,
	//
	//DECCIR reports all the character sets if they are assigned to one of the G0,
	//G1, G2, or G3 sets. Refer to SCS&#8212;Select Character Set for all character set
	//designators.
	//
	//Parameters
	//
	//D...D
	//is the data string containing the cursor information. The format for this data
	//string is as follows:
	//
	//Pr; Pc; Pp; Srend; Satt; Sflag; Pgl; Pgr; Scss; Sdesig
	//
	//Pr
	//is the number of the line the cursor is on.
	//
	//Pc
	//is the number of the column the cursor is at.
	//
	//Pp
	//is the number of the current page.
	//
	//Srend
	//is one or more characters indicating the visual attributes, such as bold or
	//blinking, currently in use for writing. To find out what attributes are set, you
	//must convert the character to an 8-bit binary number. The bits are used as
	//follows.
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//Bit
	//Attribute
	//Bit Value
	//
	//
	//
	//
	//8
	//&#8211;
	//Always 0 (off).
	//
	//
	//7
	//&#8211;
	//Always 1 (on).
	//
	//
	//6
	//Extension
	//indicator
	//1
	//=
	//another character (byte) of visual
	//attribute data follows this one.
	//
	//
	//0
	//=
	//no more attribute data.
	//
	//
	//5
	//&#8211;
	//Always 0 (off).
	//
	//
	//4
	//Reverse video
	//0
	//=
	//off.
	//
	//
	//1
	//=
	//on.
	//
	//
	//3
	//Blinking
	//0
	//=
	//off.
	//
	//
	//1
	//=
	//on.
	//
	//
	//2
	//Underline
	//0
	//=
	//off.
	//
	//
	//1
	//=
	//on.
	//
	//
	//1
	//Bold
	//0
	//=
	//off.
	//
	//
	//1
	//=
	//on.
	//
	//
	//Example
	//If the bold and underline attributes are currently set for writing, Srend is the
	//ASCII uppercase C character (010000112).
	//
	//
	//
	//
	//Satt
	//is one or more characters indicating any selective erase attributes currently set
	//for writing.
	//
	//To find what attributes are set, you must convert each character to an 8-bit
	//binary number. Use the following table to find the meaning of the 8-bit binary
	//number:
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//Bit
	//Attribute
	//Bit Value
	//
	//
	//
	//
	//8
	//&#8211;
	//Always 0 (off).
	//
	//
	//7
	//&#8211;
	//Always 1 (on).
	//
	//
	//6
	//Extension
	//indicator
	//1
	//=
	//another character (byte) of selective erase
	//data follows this one.
	//
	//
	//0
	//=
	//no more protection data.
	//
	//
	//5
	//&#8211;
	//0
	//
	//Reserved for future use.
	//
	//
	//4
	//&#8211;
	//0
	//
	//Reserved for future use.
	//
	//
	//3
	//&#8211;
	//0
	//
	//Reserved for future use.
	//
	//
	//2
	//&#8211;
	//0
	//
	//Reserved for future use.
	//
	//
	//1
	//Selective erase
	//(DECSCA)
	//0
	//=
	//off.
	//
	//
	//1
	//=
	//on.
	//
	//
	//Example
	//If the selective erase protection attribute is currently set for writing, then Satt is
	//the ASCII uppercase A character (010000012).
	//
	//
	//
	//
	//Sflag
	//is one or more characters that indicate several flags and modes the terminal must
	//save.
	//
	//To see the current state of the flags and modes, you must convert each character
	//to an 8-bit binary number. Use the following table to find the meaning of the
	//8-bit binary number:
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//Bit
	//Attribute
	//Bit Value
	//
	//
	//
	//
	//8
	//&#8211;
	//Always 0 (off).
	//
	//
	//7
	//&#8211;
	//Always 1 (on).
	//
	//
	//6
	//Extension
	//indicator
	//1
	//=
	//another character (byte) of flag data follows
	//this one.
	//
	//
	//0
	//=
	//no more flag data.
	//
	//
	//5
	//&#8211;
	//0
	//
	//Reserved for future use.
	//
	//
	//4
	//Autowrap
	//1
	//=
	//autowrap pending.
	//
	//
	//0
	//=
	//autowrap not pending.
	//
	//
	//3
	//Single shift 3
	//(SS3) setting
	//1
	//=
	//G3 is mapped into GL for the next typed
	//character only.
	//
	//
	//0
	//=
	//single shift 3 is off.
	//
	//
	//2
	//Single shift 2
	//(SS2) setting
	//1
	//=
	//G2 is mapped into GL for the next typed
	//character only.
	//
	//
	//0
	//=
	//single shift 2 is off.
	//
	//
	//1
	//Origin mode
	//1
	//=
	//origin mode set.
	//
	//
	//0
	//=
	//origin mode reset.
	//
	//
	//Example
	//If origin mode is set, autowrap is pending, and a single shift 3 has been received,
	//then Sflag is the ASCII uppercase M character (010011012).
	//
	//
	//
	//
	//Pgl
	//indicates the number of the logical character set (G0 through G3) mapped into
	//GL.
	//
	//
	//
	//
	//0 = G0 is in GL.
	//2 = G2 is in GL.
	//
	//
	//1 = G1 is in GL.
	//3 = G3 is in GL.
	//
	//
	//
	//
	//Pgr
	//indicates the number of the logical character set (G0 through G3) mapped into
	//GR.
	//
	//
	//
	//
	//0 = G0 is in GR.
	//2 = G2 is in GR.
	//
	//
	//1 = G1 is in GR.
	//3 = G3 is in GR.
	//
	//
	//
	//
	//Scss
	//is a character indicating the size of the character sets in G0 through G3.
	//
	//To find out what the character means, you must convert it to an 8-bit binary
	//number. Use the following table to find the meaning of the 8-bit binary number:
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//Bit
	//Attribute
	//Bit Value
	//
	//
	//
	//
	//8
	//&#8211;
	//Always 0 (off).
	//
	//
	//7
	//&#8211;
	//Always 1 (on).
	//
	//
	//6
	//Extension
	//indicator
	//1
	//=
	//another character (byte) of character size
	//data follows this one.
	//
	//
	//0
	//=
	//no more size data.
	//
	//
	//5
	//&#8211;
	//0
	//
	//Reserved for future use.
	//
	//
	//4
	//G3 set size
	//0
	//=
	//94 characters.
	//
	//
	//1
	//=
	//96 characters.
	//
	//
	//3
	//G2 set size
	//0
	//=
	//94 characters.
	//
	//
	//1
	//=
	//96 characters.
	//
	//
	//2
	//G1 set size
	//0
	//=
	//94 characters.
	//
	//
	//1
	//=
	//96 characters.
	//
	//
	//1
	//G0 set size
	//0
	//=
	//94 characters.
	//
	//
	//1
	//=
	//96 characters.
	//
	//
	//Example
	//Suppose the following conditions exist:
	//
	//The ISO Latin-1 supplemental set is designated as G2 and G3.
	//The ASCII set is designated as G0 and G1.
	//Single shift 2 (SS2) is set.
	//
	//Then Scss is the ASCII backslash \ character (010111002).
	//
	//
	//
	//
	//Sdesig
	//is a string of intermediate and final characters indicating the character sets
	//designated as G0 through G3. These final characters are the same as those used
	//in select character set (SCS) sequences.
	//
	//Example
	//
	//Suppose the ASCII character set is designated as G0, DEC Special Graphic as
	//G1, and DEC Supplemental Graphic as G2 and G3. The Sdesig string would be
	//B0%5%5. Each character corresponds to a final character in an SCS sequence, as
	//follows:
	//
	//
	//
	//
	//G0
	//G1
	//G2
	//G3
	//
	//
	//B
	//0
	//%5
	//%5
	//
	//
	//ASCII set
	//DEC Special Graphic
	//DEC Supplemental Graphic
	//DEC Supplemental Graphic
	//
	//
	//
	//
	//Example
	//
	//The following is an example of a cursor information report:
	//
	//DCS 1 $ u 1; 1; 1; @; @; @; 0; 2; @; BB%5%5 ST
	//
	//1; 1; 1; indicates that the cursor is at row 1, column 1, on the first page.
	//
	//@; @; @; indicates that (1) no visual character attributes or selective erase
	//attributes are set for writing, (2) DECOM is reset, and (3) there is no SS2, SS3,
	//or autowrap pending.
	//
	//0; 2; indicates that G0 is mapped into GL, and G2 is in GR.
	//
	//@; indicates that all character sets have 94 characters.
	//
	//BB%5%5 indicates that ASCII is in G0 and G1, and DEC Supplemental Graphic
	//is in G2 and G3.
	//
	//Notes on DECCIR
	//
	//
	//The cursor information in a DECCIR sequence is the same information saved
	//through a save cursor (DECSC) command.
	//
	//
	//Format:
	//	DCS 1  $  u  D ... D ST
	//	90  31 24 75 D ... D 9C
	//
	//Parameters:
	//	To see the current state of the flags and modes, you must convert each character- to an 8-bit binary number. Use the following table to find the meaning of the
	//8-bit binary number:	Pc- is the number of the column the cursor is at.	1- Pr; Pc; Pp; Srend; Satt; Sflag; Pgl; Pgr; Scss; Sdesig	19- 1; 1; 1; indicates that the cursor is at row 1, column 1, on the first page.	D...D- is the data string containing the cursor information. The format for this data
	//string is as follows:	Sdesig- is a string of intermediate and final characters indicating the character sets
	//designated as G0 through G3. These final characters are the same as those used
	//in select character set (SCS) sequences.	Srend- is one or more characters indicating the visual attributes, such as bold or
	//blinking, currently in use for writing. To find out what attributes are set, you
	//must convert the character to an 8-bit binary number. The bits are used as
	//follows.	Pp- is the number of the current page.	18- DCS 1 $ u 1; 1; 1; @; @; @; 0; 2; @; BB%5%5 ST	Sflag- is one or more characters that indicate several flags and modes the terminal must
	//save.	Suppose the ASCII character set is designated as G0, DEC Special Graphic as- G1, and DEC Supplemental Graphic as G2 and G3. The Sdesig string would be
	//B0%5%5. Each character corresponds to a final character in an SCS sequence, as
	//follows:	15- Example	Pr- is the number of the line the cursor is on.	Pgr- indicates the number of the logical character set (G0 through G3) mapped into
	//GR.	22- @; indicates that all character sets have 94 characters.	To find what attributes are set, you must convert each character to an 8-bit- binary number. Use the following table to find the meaning of the 8-bit binary
	//number:	To find out what the character means, you must convert it to an 8-bit binary- number. Use the following table to find the meaning of the 8-bit binary number:	Satt- is one or more characters indicating any selective erase attributes currently set
	//for writing.	21- 0; 2; indicates that G0 is mapped into GL, and G2 is in GR.	Pgl- indicates the number of the logical character set (G0 through G3) mapped into
	//GL.	17- The following is an example of a cursor information report:	Scss- is a character indicating the size of the character sets in G0 through G3.	@; @; @; indicates that (1) no visual character attributes or selective erase- attributes are set for writing, (2) DECOM is reset, and (3) there is no SS2, SS3,
	//or autowrap pending.

	DECCKD, CopyKeyDefault AnsiEscapeType = iota, iota
	//Copy Key Default (DECCKD)
	//Copies the default states of a key and its key/modifier combination to another key
	//and its key/modifier combination.
	//
	//This control function copies the default states of a key and all its modifier
	//combinations to another key and its modifier combinations. The source key may
	//have been reprogrammed to perform a non-default function when copy operation
	//is executed. Only the default states of the source key are copied.
	//
	//The source key and the destination key can be two different keys or the same key.
	//If they are different keys, then the copy operation occupies the memory space
	//that is reserved for the operations of control functions, DECPFK, DECPAK, and
	//DECUDK and their equivalent functions in Set-Up. (Refer to DECPFK&#8212;Program
	//Function Key for details.) If they are the same key, then the function of the
	//copy operation is to restore the key's default. In this state, the terminal does
	//not allocate new memory space. The terminal frees up the space by deleting the
	//non-default functions of the destination key and its modifier combinations.
	//
	//A function key can copy the default state from a function key or a graphic key.
	//When a graphic key's default is copied, the function key operates as a graphic
	//key. Only the modifiers that are suitable for a graphic key operate with the key.
	//This logic is used when a graphic key copies the default from a function key.
	//
	//Multiple keys can be copied in one sequence.
	//
	//The data string D...D format is:
	//
	//Key-s/Key-d;Key-s/Key-d........;
	//
	//Where:
	//
	//
	//Key-s is the keystation number of the key to be copied.
	//Key-d is the keystation number of the destination key.
	//
	//
	//Once programmed, the key states are not affected by the terminal mode changes.
	//Refer to DECPFK&#8212;Program Function Key for the list of terminal mode changes.
	//
	//This function works in all the VT modes except in VT52 mode.
	//
	//Format:
	//	DCS "  z  D . . . D ST
	//	90  22 7A D . . . D 9C
	//
	//Parameters:
	//	5- Where:	4- Key-s/Key-d;Key-s/Key-d........;	A function key can copy the default state from a function key or a graphic key.- When a graphic key's default is copied, the function key operates as a graphic
	//key. Only the modifiers that are suitable for a graphic key operate with the key.
	//This logic is used when a graphic key copies the default from a function key.	The source key and the destination key can be two different keys or the same key.- If they are different keys, then the copy operation occupies the memory space
	//that is reserved for the operations of control functions, DECPFK, DECPAK, and
	//DECUDK and their equivalent functions in Set-Up. (Refer to DECPFK&#8212;Program
	//Function Key for details.) If they are the same key, then the function of the
	//copy operation is to restore the key's default. In this state, the terminal does
	//not allocate new memory space. The terminal frees up the space by deleting the
	//non-default functions of the destination key and its modifier combinations.	2- Multiple keys can be copied in one sequence.	Once programmed, the key states are not affected by the terminal mode changes.- Refer to DECPFK&#8212;Program Function Key for the list of terminal mode changes.	3- The data string D...D format is:

	DECCKM, CursorKeysMode AnsiEscapeType = iota, iota
	//Cursor Keys Mode (DECCKM)
	//This control function selects the sequences the arrow keys send. You can use the
	//four arrow keys to move the cursor through the current page or to send special
	//application commands.
	//
	//If the DECCKM function is set, then the arrow keys send application sequences
	//to the host.
	//
	//If the DECCKM function is reset, then the arrow keys send ANSI cursor
	//sequences to the host.
	//
	//Format:
	//	CSI ?  1  h
	//	9B  3F 31 68
	//	CSI ?  1  l
	//	9B  3F 31 6C
	//

	DECCKSR, MemoryChecksumReport AnsiEscapeType = iota, iota
	//Memory Checksum Report (DECCKSR)
	//The host asks for a memory checksum report of current text macro definitions.
	//
	//
	//
	//Format:
	//	CSI ?  6  3  ;  Pid n
	//	9B  3F 36 33 3B 3n  6E
	//	DCS Pid !  ~  D . . . D ST
	//	90  3n  21 7E . . .     9C
	//
	//Parameters:
	//	Pid (response)- is a label indicating which DSR request the report is for.	Pid (request)- is an optional numeric parameter that provides a label to identify the particular
	//checksum request. The checksum report returns the label. This label lets you
	//distinguish between multiple checksum reports.

	DECCRA, CopyRectangularArea AnsiEscapeType = iota, iota
	//Copy Rectangular Area (DECCRA)
	//This control function copies a rectangular area of characters from one section
	//to another in page memory. The copied text retains its character values and
	//attributes.
	//
	//
	//
	//Format:
	//	CSI Pts; Pls; Pbs; Prs; Pps; Ptd; Pld; Ppd $  v
	//	9B  area to be copied        destination   24 76
	//
	//Parameters:
	//	Pts- is the top-line border. Pts must be less than or equal to Pbs. Default: Pts = 1.	Prs- is the right-column border.
	//Default: Prs = the last column of the page.	Pbs- is the bottom-line border.
	//Default: Pbs = the last line of the page.	Ptd- is the top-line border.
	//Default: Ptd = 1.	Pls- is the left-column border. Pls must be less than or equal to Prs. Default: Pls = 1.	Pts; Pls; Pbs; Prs; Pps;- define the rectangular area to be copied (the source). A semicolon (3/11) separates
	//parameters.	Pld- is the left-column border.
	//Default: Pld = 1.	Ptd; Pld; Ppd;- define the destination of the copied rectangular area.	Pps- is the number of the page where the rectangular area is located.
	//Default: Pps = 1.

	DECCRTSM, SetResetCRTSaveMode AnsiEscapeType = iota, iota
	//Set/Reset CRT Save Mode (DECCRTSM)
	//Enable or disable CRT saver.
	//
	//If CRT saver is enabled and the terminal is inactive for 30 minutes (no keyboard
	//activity or input from a host computer), then the monitor screen goes blank to
	//prolong the life of the CRT. No data is lost when CRT saver is active. Keyboard
	//activity or input from the host computer re-activates the monitor.
	//
	//When the monitor goes blank, the keyboard LEDs flash.
	//
	//Format:
	//	CSI ?  9  7  h
	//	9B  3F 39 37 68
	//	CSI ?  9  7  l
	//	9B  3F 39 37 6C
	//

	DECDC, DeleteColumn AnsiEscapeType = iota, iota
	//Delete Column (DECDC)
	//This control function deletes one or more columns in the scrolling region, starting
	//with the column that has the cursor.
	//
	//As columns are deleted, the remaining columns between the cursor and the
	//right margin move to the left. The terminal adds blank columns with no visual
	//character attributes at the right margin. DECDC has no effect outside the
	//scrolling margins.
	//
	//Format:
	//	CSI Pn '  ~
	//	9B  3n 27 7E
	//
	//Parameters:
	//	Pn- is the number of columns to delete.
	//Default: Pn = 1.

	DECDHL, DoubleWidthDoubleHeightLine AnsiEscapeType = iota, iota
	//Double-Width, Double-Height Line (DECDHL)
	//These two control functions make the line with the cursor the top or bottom half
	//of a double-height, double-width line. You must use these sequences in pairs
	//on adjacent lines. In other words, the same display characters must appear in
	//the same positions on both lines to form double-height characters. If the line
	//was single width and single height, then all characters to the right of the screen
	//center are lost.
	//
	//The following sequences make the phrase "VT510 Video Terminal" a double-height,
	//double-width line.
	//
	//ESC#3 VT510 Video Terminal
	//ESC#4 VT510 Video Terminal
	//
	//Format:
	//	ESC #  3
	//	1B  23 33
	//	ESC #  4
	//	1B  23 34
	//

	DECDLD, DynamicallyRedefinableCharacterSets AnsiEscapeType = iota, iota
	//Dynamically Redefinable Character Sets (DECDLD)
	//DECDLD loads your soft character set into dynamically redefinable character set
	//(DRCS) font buffers. Although the terminal has six font buffers, it only supports
	//four buffers for soft character sets.
	//
	//DCS is the device control string introducer. DCS is an 8-bit C1 character. You
	//can use the equivalent 7-bit sequence, ESC P (1/11, 5/0), when coding for a 7-bit
	//environment.
	//
	//ST is the string terminator. ST is an 8-bit C1 character. You can use
	//the equivalent 7-bit sequence, ESC \ (1/11, 5/12), when coding for a 7-bit
	//environment.
	//
	//Parameters
	//
	//Pfn; Pcn; Pe; Pcmw; Pss; Pt; Pcmh; Pcss
	//are parameter characters, separated by semicolons (3/11). Table 5&#8211;2 describes
	//these parameters and lists their possible values. Table 5&#8211;3 describes the
	//combinations of Pcmw, Pt, and Pcmh that you can use for 80- and 132-column
	//fonts. If you use any other combinations, then the terminal ignores the DECDLD
	//string.
	//
	//{
	//is the final character. It marks the end of the parameter characters and indicates
	//that this string is a DECDLD function.
	//
	//Dscs
	//defines the name for the soft character set. You use this name in the select
	//character set (SCS) escape sequence. You use the following format for the Dscs
	//name:
	//
	//I F
	//
	//
	//
	//
	//I
	//is 0, 1, or 2 intermediate characters from the 2/0 to 2/15 range in the
	//ASCII character set.
	//
	//
	//F
	//is a final character in the 3/0 to 7/14 range.
	//
	//
	//
	//
	//Notes
	//
	//If two downline loaded soft character sets have the same Dscs,
	//then the most recently loaded set is used. The terminal looks for a
	//matching Dscs in reverse load order (last loaded first).
	//If the terminal receives a DRCS control string for a given font number
	//with a different Dscs (designating sequence), Pcmh (height) or Pcss
	//(character set size), then the terminal erases the previously downline
	//loaded set (if any) in both 80- and 132-column mode.
	//If there is no DRCS available that is compatible with the current
	//number of lines per screen (font height), then the terminal displays a
	//reverse question mark in place of any characters.
	//
	//
	//Examples of Dscs Names
	//
	//
	//
	//
	//
	//
	//
	//
	//Name
	//Function
	//
	//
	//
	//
	//SP2/0
	//@4/0
	//
	//Defines the character set as an unregistered soft set.
	//This value is the recommended default for user-defined
	//sets. The value of Pcss defines whether this
	//set has 94 or 96 characters.
	//
	//
	//A4/2
	//
	//
	//If Pcss is 0, then A defines the soft character set as the
	//U.K. national replacement character set.
	//If Pcss is 1, then A defines the soft character set as the
	//ISO Latin-1 supplemental set.
	//
	//
	//&amp;2/6
	//%2/5
	//C4/3
	//Defines the soft character set as % C, which is currently
	//an unregistered set. The value of Pcss defines whether
	//this set has 94 or 96 characters.
	//
	//
	//
	//
	//Sxbp1 ; Sxbp2 ; . . . ; Sxbpn
	//are the sixel bit patterns for individual characters, separated by semicolons (3/11).
	//Your character set can have 1 to 94 patterns or 1 to 96 patterns, depending on
	//the setting of the character set size parameter (Pcss). Each sixel bit pattern is in
	//the following format:
	//
	//S...S/S...S
	//
	//the first S...S
	//represents the sixels in Group A of the soft character.
	//
	/// (2/5)
	//advances the sixel pattern to Group B of the soft character.
	//
	//the second S...S
	//represents the sixels in Group B of the soft character.
	//
	//
	//Table 5&#8211;2 DECDLD Parameter Characters
	//
	//
	//
	//
	//
	//Parameter
	//Name
	//Description
	//
	//
	//
	//
	//Pfn
	//Font number
	//Selects the DRCS (soft character set) to load.
	//The previous set (if any), that you load with
	//that font number, is erased or overwritten
	//as specified by the control sequence. You can
	//assign a value of 0, 1, and 2 to Pfn. Other
	//values cause the terminal to ignore the entire
	//sequence. Pfn = 0 defaults to the first empty
	//font buffer, or, if none are empty, to font buffer
	//1.
	//
	//
	//Pcn
	//Starting
	//character
	//Selects where to load the first character in the
	//DRCS font buffer. The location corresponds
	//to a location in the ASCII code table. For
	//example, a Pcn value of 0 means that the first
	//soft character is loaded into position 2/0 of the
	//character table. A Pcn value of 1 means position
	//2/1 in the table, and so on, up to
	//Pcn = 95 (position 7/15).
	//Pcn is affected by the character set size. See
	//Pcss below.
	//
	//
	//Pe
	//Erase control
	//Selects which characters to erase from the
	//DRCS buffer before loading the new font.
	//
	//
	//
	//0
	//=
	//Erases all characters in the DRCS
	//buffer with this number, width, and
	//rendition.
	//
	//
	//1
	//=
	//Erases only characters in locations
	//being reloaded.
	//
	//
	//2
	//=
	//Erases all renditions of the soft
	//character set (normal, bold, 80-column, 132-column).
	//
	//
	//
	//Note
	//Erased characters are undefined (not
	//blank). The terminal displays these
	//characters as the error character (reverse
	//question mark).
	//
	//
	//Pcmw
	//Character
	//matrix width
	//Selects the maximum character cell width.
	//When Pss specifies 80 columns, Pt specifies font
	//usage full cell as follows:
	//
	//
	//
	//0
	//=
	//10 pixels wide for 80 columns,
	//6 pixels wide for 132 columns.
	//(default).
	//
	//
	//2
	//=
	//5 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//3
	//=
	//6 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//4
	//=
	//7 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//5
	//=
	//5 pixels wide.
	//
	//
	//6
	//=
	//6 pixels wide.
	//
	//
	//...
	//
	//
	//
	//
	//10
	//=
	//10 pixels wide.
	//
	//
	//
	//When Pss specifies 80 columns, Pt specifies font
	//usage text as follows:
	//
	//
	//
	//0
	//=
	//10 pixels wide for 80 columns,
	//6 pixels wide for 132 columns.
	//(default)
	//
	//
	//2
	//=
	//5 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//3
	//=
	//6 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//4
	//=
	//7 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//5
	//=
	//5 pixels wide.
	//
	//
	//...
	//
	//
	//
	//
	//9
	//=
	//9 pixels wide.
	//
	//
	//
	//When Pss specifies 132 columns, Pt specifies
	//font usage full cell as follows:
	//
	//
	//
	//0
	//=
	//10 pixels wide for 80 columns,
	//6 pixels wide for 132 columns.
	//(default)
	//
	//
	//2
	//=
	//5 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//3
	//=
	//6 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//4
	//=
	//7 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//5
	//=
	//5 pixels wide.
	//
	//
	//6
	//=
	//6 pixels wide.
	//
	//
	//
	//When Pss specifies 132 columns, Pt specifies
	//font usage text as follows:
	//
	//
	//
	//0
	//=
	//10 pixels wide for 80 columns,
	//6 pixels wide for 132 columns.
	//(default)
	//
	//
	//2
	//=
	//5 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//3
	//=
	//6 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//4
	//=
	//7 &#215; 10 pixel cell (width &#215; height).
	//
	//
	//5
	//=
	//5 pixels wide.
	//
	//
	//
	//If you omit a Pcmw value, the terminal uses the
	//default character width. If the Pe parameter
	//is 0, Pcmw must be less than 10. Any Pcmw
	//value over 10 is illegal. For illegal values of
	//Pcmw, the terminal ignores the rest of the load
	//sequence.
	//
	//
	//For VT200 compatible software: Use a Pcmw value of 2, 3, or 4. When you
	//use these values, the VT510 doubles the height of the font definitions in memory.
	//This makes the soft set the same height as the hard sets. If you use a Pcmw
	//value of 0, then the VT510 does not double the height and the soft set appears
	//smaller than the hard sets. Remember that the VT200 fonts may appear different
	//on the VT510.
	//For fonts designed for the VT510: Use values 5 through 10.
	//For compatibility between VT200 and VT510 terminals: Use a Pcmw value
	//of 5, 6, or 7.
	//
	//
	//Pss
	//Font set size
	//Defines the screen width and screen height for
	//this font.
	//
	//
	//
	//0,1
	//=
	//80 columns, 24 lines. (default)
	//
	//
	//2
	//=
	//132 columns, 24 lines
	//
	//
	//11
	//=
	//80 columns, 36 lines
	//
	//
	//12
	//=
	//132 columns, 36 lines
	//
	//
	//21
	//=
	//80 columns, 48 lines
	//
	//
	//22
	//=
	//132 columns, 48 lines
	//
	//
	//
	//For illegal values of Pss, the terminal ignores
	//the rest of the load sequence.
	//If the number of columns or lines/screen
	//changes, then the terminal uses the appropriate
	//variation of the soft set. If you try to display
	//a DRCS character when there is no soft set
	//defined for the current number of lines and
	//columns, then the terminal displays the error
	//character (reverse question mark).
	//
	//
	//
	//Note
	//For VT220 compatibility, you must use a soft font of 80 or
	//132 columns (not both). The VT220 allows a single font to
	//be used for 80 and 132 columns.
	//
	//
	//
	//
	//You can load a font for any of the six sizes at
	//any time. When a new soft set is loaded, any
	//characters from the previous soft set are lost.
	//Characters currently displayed from the old set
	//become reverse question marks.
	//
	//
	//Pt
	//Text or full
	//cell
	//Defines the font as a text font or full-cell font.
	//
	//
	//
	//0
	//=
	//text. (default)
	//
	//
	//1
	//=
	//text.
	//
	//
	//2
	//=
	//full cell.
	//
	//
	//
	//Full-cell fonts can individually address all pixels
	//in a cell.
	//Text fonts cannot individually address all pixels.
	//If you specify a text cell, then the terminal
	//automatically performs spacing and centering of
	//the characters.
	//
	//
	//Pcmh
	//Character
	//matrix
	//height
	//Selects the maximum character cell height.
	//
	//
	//
	//0 or omitted
	//=
	//16 pixels high. (default)
	//
	//
	//1
	//=
	//1 pixel high.
	//
	//
	//2
	//=
	//2 pixels high.
	//
	//
	//3
	//=
	//3 pixels high.
	//
	//
	//...
	//
	//
	//
	//
	//16
	//=
	//16 pixels high.
	//
	//
	//
	//Pcmh values over 16 are illegal. If the value of
	//Pcmw is 2, 3, or 4, then Pcmh is ignored.
	//
	//
	//Pcss
	//Character
	//set size
	//Defines the character set as a 94- or 96-
	//character graphic set.
	//
	//
	//
	//0
	//=
	//94-character set. (default)
	//
	//
	//1
	//=
	//96-character set.
	//
	//
	//
	//The value of Pcss changes the meaning of the
	//Pcn (starting character) parameter above.
	//
	//
	//
	//If Pcss = 0 (94-character set)
	//The terminal ignores any attempt to load characters into the 2/0
	//or 7/15 table positions.
	//
	//
	//
	//Pcn
	//Specifies
	//
	//
	//
	//1
	//column 2/row 1
	//
	//
	//
	//
	//...
	//
	//
	//
	//94
	//column 7/row 14
	//
	//
	//
	//If Pcss = 1 (96-character set)
	//
	//
	//
	//Pcn
	//Specifies
	//
	//
	//
	//0
	//column 2/row 0
	//
	//
	//
	//
	//...
	//
	//
	//
	//95
	//column 7/row 15
	//
	//
	//
	//
	//
	//Table 5&#8211;3 Valid DECDLD Parameter Combinations
	//
	//
	//
	//
	//
	//
	//Pt
	//Pcmw
	//Pcmh
	//Pss&#8224;
	//
	//
	//
	//
	//&#8224;The default values are the maximum legal values in each case.
	//
	//
	//
	//
	//80-column, 24 lines
	//
	//
	//
	//
	//
	//0 or 1
	//0 to 8
	//0 to 16
	//0 or 1
	//
	//
	//2
	//0 to 10
	//0 to 16
	//0, 1
	//
	//
	//132-column, 24 lines
	//
	//
	//
	//
	//
	//0 or 1
	//0 to 5
	//0 to 16
	//2
	//
	//
	//2
	//0 to 6
	//1 to 16
	//2
	//
	//
	//80-column, 36 lines
	//
	//
	//
	//
	//
	//0 or 1
	//0 to 8
	//0 to 10
	//11
	//
	//
	//2
	//0 to 10
	//0 to 10
	//11
	//
	//
	//132-column, 36 lines
	//
	//
	//
	//
	//
	//0 or 1
	//0 to 5
	//0 to 10
	//12
	//
	//
	//2
	//0 to 6
	//0 to 10
	//12
	//
	//
	//80-column, 48 lines
	//
	//
	//
	//
	//
	//0 or 1
	//0 to 8
	//0 to 8
	//21
	//
	//
	//2
	//0 to 10
	//0 to 8
	//21
	//
	//
	//132-column, 48 lines
	//
	//
	//
	//
	//
	//0 or 1
	//0 to 5
	//0 to 8
	//22
	//
	//
	//2
	//0 to 6
	//0 to 8
	//22
	//
	//
	//
	//
	//Note
	//For illegal combinations of the Pss, Pt, Pcmw, and Pcmh parameters, the
	//terminal ignores the rest of the sequence.
	//
	//
	//Table 5&#8211;4 VT510 Font Sizes
	//
	//
	//
	//
	//
	//80 Columns
	//132 Columns
	//Maximum Number of Lines
	//
	//
	//
	//
	//10 &#215; 16
	//6 &#215; 16
	//26 lines + keyboard indicator line
	//
	//
	//10 &#215; 10
	//6 &#215; 10
	//42 lines + keyboard indicator line
	//
	//
	//10 &#215; 8
	//6 &#215; 8
	//53 lines + keyboard indicator line
	//
	//
	//10 &#215; 13
	//6 &#215; 13
	//26 lines + keyboard indicator line
	//(72 Hz with overscan)
	//
	//
	//
	//
	//Format:
	//
	//Parameters:
	//	7- I F	Although the terminal allows you to use two different soft character sets at one- time, it only allows you to use one DRCS set at one time.	Dscs- defines the name for the soft character set. You use this name in the select
	//character set (SCS) escape sequence. You use the following format for the Dscs
	//name:	DCS Pfn ; Pcn; Pe; Pcmw; Pss; Pt; Pcmh; Pcss f Dscs Sxbp1 ; Sxbp2 ; . . . ; Sxbpn- ST	ST is the string terminator. ST is an 8-bit C1 character. You can use- the equivalent 7-bit sequence, ESC \ (1/11, 5/12), when coding for a 7-bit
	//environment.	the first S...S- represents the sixels in Group A of the soft character.	DCS is the device control string introducer. DCS is an 8-bit C1 character. You- can use the equivalent 7-bit sequence, ESC P (1/11, 5/0), when coding for a 7-bit
	//environment.	{- is the final character. It marks the end of the parameter characters and indicates
	//that this string is a DECDLD function.	Pfn; Pcn; Pe; Pcmw; Pss; Pt; Pcmh; Pcss- are parameter characters, separated by semicolons (3/11). Table 5&#8211;2 describes
	//these parameters and lists their possible values. Table 5&#8211;3 describes the
	//combinations of Pcmw, Pt, and Pcmh that you can use for 80- and 132-column
	//fonts. If you use any other combinations, then the terminal ignores the DECDLD
	//string.	/ (2/5)- advances the sixel pattern to Group B of the soft character.	10- S...S/S...S	Sxbp1 ; Sxbp2 ; . . . ; Sxbpn- are the sixel bit patterns for individual characters, separated by semicolons (3/11).
	//Your character set can have 1 to 94 patterns or 1 to 96 patterns, depending on
	//the setting of the character set size parameter (Pcss). Each sixel bit pattern is in
	//the following format:	8- Examples of Dscs Names

	DECDMAC, DefineMacro AnsiEscapeType = iota, iota
	//Define Macro (DECDMAC)
	//This device control string lets you define a macro consisting of a string of ANSI
	//text and control functions. After you define the macro, you can execute it by using
	//the invoke macro control function (DECINVM). The terminal processes the macro
	//as normal input.
	//
	//
	//
	//Format:
	//	DCS Pid ;  Pdt ;  Pen !  z  D . . . D ST
	//	90  3?  3B 3?  3B 3?  21 7A ...       9C
	//
	//Parameters:
	//	Pen- selects the encoding format for the text of the macro definition.	Pdt- defines how the terminal treats new macro definitions.	Programming Tip- You can find how much memory space you have available for macros by using a
	//device status report sequence.	Pid- is the macro ID number. Pid can be any number between 0 and 63, otherwise
	//the terminal ignores the command. If you give a macro an ID that already exists,
	//then DECDMAC deletes the old macro definition before using the new one.

	DECDWL, DoubleWidthSingleHeightLine AnsiEscapeType = iota, iota
	//Double-Width, Single-Height Line (DECDWL)
	//This control function makes the line with the cursor a double-width, single-height
	//line. If the line was single width and single height, then all characters to the
	//right of the screen's center are lost.
	//
	//
	//
	//Format:
	//	ESC #  6
	//	1B  23 36
	//

	DECEKBD, ExtendedKeyboardReport AnsiEscapeType = iota, iota
	//Extended Keyboard Report (DECEKBD)
	//This control function is a report that provides applications with more complete
	//keystroke information. Each report consists of an ISO key position code and the
	//current state of the eight modifier keys—pressed or released.
	//
	//The terminal only sends extended key position reports when key position mode
	//(DECKPM) is set.
	//
	//The terminal uses the following rules when sending extended key reports:
	//
	//
	//A single report may contain more than one keystroke. In this case, each
	//keystroke is separated by a slash (/). The terminal sends the control string
	//(APC ... ST) when a modifier key changes, or to separate keystroke data from
	//other terminal reports.
	//The terminal only sends the modifier key state when it changes in the first
	//keystroke after an APC character.
	//The terminal sends repeated key position reports as a single repeat character,
	//period (.).
	//
	//
	//Examples
	//
	//The following sequence reports an a key with no modifier keys, four  keys,
	//one  key, and a b key:
	//
	//APC : C01 00 / B18.../ B16 / B05 ST
	//
	//The following sequence reports a left Shift key and an A key:
	//
	//APC : B99 01 / C01 ST
	//
	//Format:
	//	APC :  ppp mm ST
	//	9F  3A *** ** 9C
	//
	//Parameters:
	//	7- APC : C01 00 / B18.../ B16 / B05 ST	The following table shows the order in which keys are represented in the binary- number, and their corresponding hexadecimal values when pressed. The least
	//significant bit represents the left Shift key. The most significant bit represents the
	//right Compose&#160;Character key.	5- The terminal uses the following rules when sending extended key reports:	The terminal represents the state of each modifier key as a bit in an 8-bit binary- number. A bit value of 1 means the key is pressed, and a bit value of 0 means
	//the key is not pressed. mm is the hexadecimal equivalent of the resulting 8-bit
	//binary number.	The terminal only sends extended key position reports when key position mode- (DECKPM) is set.	For example, 000000102 means that the right Shift key is pressed. The- hexadecimal value for 000000102 is 0216.	mm- are two ASCII hexadecimal digits that represent the state of the modifier keys.	The following sequence reports an a key with no modifier keys, four  keys,- one  key, and a b key:	8- The following sequence reports a left Shift key and an A key:

	DECELF, EnableLocalFunctions AnsiEscapeType = iota, iota
	//Enable Local Functions (DECELF)
	//This control function lets you enable or disable the keys used to perform several
	//local terminal functions: cutting and pasting text, panning, and resizing windows.
	//DECELF is useful for:
	//
	//DECELF can accept any number of parameter pairs. The terminal executes the
	//parameters in the order in which it receives them.
	//
	//Format:
	//	CSI Pf1 ;  Pc1 ;  ... Pfn ;  Pcn +  q
	//	9B  3n  3B 3n  3B ... 3n  3B 3n  2B 71
	//
	//Parameters:
	//	Pcn- controls the action of the local function specified by the corresponding Pfn value.

	DECERA, EraseRectangularArea AnsiEscapeType = iota, iota
	//Erase Rectangular Area (DECERA)
	//This control function erases characters from the specified rectangular area in
	//page memory. When an area is erased, DECERA replaces all character positions
	//with the space character (2/0). DECERA erases character values and visual
	//attributes from the specified area. DECERA does not erase line attributes.
	//
	//
	//
	//Format:
	//	CSI Pt ;  Pl ;  Pb ;  Pr $  z
	//	9B  3n 3B 3n 3B 3n 3B 3n 24 7A
	//

	DECESKM, EnableSecondaryKeyboardLanguageMode AnsiEscapeType = iota, iota
	//Enable Secondary Keyboard Language Mode (DECESKM)
	//Select a secondary or primary keyboard language.
	//
	//When enabled, a secondary keyboard mapping replaces the primary keyboard
	//mapping. To use the secondary keyboard mapping, a secondary keyboard
	//language has to be defined. See Chapter 8 for information on secondary keyboard
	//languages.
	//
	//Format:
	//	CSI ?  1  0  4  h
	//	9B  3F 31 30 34 38
	//	CSI ?  1  0  4  l
	//	9B  3F 31 30 34 6C
	//

	DECFI, ForwardIndex AnsiEscapeType = iota, iota
	//Forward Index (DECFI)
	//This control function moves the cursor forward one column. If the cursor is at the
	//right margin, then all screen data within the margins moves one column to the
	//left. The column shifted past the left margin is lost.
	//
	//DECFI adds a new column at the right margin, with no visual attributes. DECFI
	//is not affected by the margins. If the cursor is at the right border of the page
	//when the terminal receives DECFI, then the terminal ignores DECFI.
	//
	//Format:
	//	ESC 9
	//	1B  36
	//

	DECFNK, FunctionKey AnsiEscapeType = iota, iota
	//Function Key (DECFNK)
	//The DECFNK sequences encode the top row function keys, the six editing keypad
	//keys, and the four cursor keys. The top row function keys, (
	//
	//All combinations of the listed modifiers are coded as shown in Table 5&#8211;5.
	//
	//
	//Table 5&#8211;5 DECFNK Modifiers
	//
	//
	//
	//
	//
	//Ps1
	//Function Keystroke
	//Modifiers Coded by Default
	//
	//
	//
	//
	//1
	//Find
	//Unmodified, Control, Alt
	//
	//
	//2
	//Insert&#160;Here
	//Unmodified, Control, Alt
	//
	//
	//3
	//Remove
	//Unmodified, Control, Alt
	//
	//
	//4
	//Select
	//Unmodified, Control, Alt
	//
	//
	//5
	//Prev
	//Unmodified, Alt
	//
	//
	//6
	//Next
	//Unmodified, Alt
	//
	//
	//7
	//
	//Alt
	//
	//
	//8
	//
	//Alt
	//
	//
	//9
	//
	//Alt
	//
	//
	//10
	//
	//Alt
	//
	//
	//11
	//F1
	//Unmodified, Shift, Control, Alt
	//
	//
	//12
	//F2
	//Unmodified, Shift, Control, Alt
	//
	//
	//13
	//F3
	//Unmodified, Shift, Control, Alt
	//
	//
	//14
	//F4
	//Unmodified, Shift, Control, Alt
	//
	//
	//15
	//F5
	//Unmodified, Shift, Control, Alt
	//
	//
	//17
	//F6
	//Unmodified, Shift, Control, Alt
	//
	//
	//18
	//F7
	//Unmodified, Shift, Control, Alt
	//
	//
	//19
	//F8
	//Unmodified, Shift, Control, Alt
	//
	//
	//20
	//F9
	//Unmodified, Shift, Control, Alt
	//
	//
	//21
	//F10
	//Unmodified, Shift, Control, Alt
	//
	//
	//23
	//F11
	//Unmodified, Shift, Control, Alt
	//
	//
	//24
	//F12
	//Unmodified, Shift, Control, Alt
	//
	//
	//25
	//F13
	//Unmodified, Shift, Control, Alt
	//
	//
	//26
	//F14
	//Unmodified, Shift, Control, Alt
	//
	//
	//28
	//Help
	//Unmodified, Shift, Control, Alt
	//
	//
	//29
	//Do
	//Unmodified, Shift, Control, Alt
	//
	//
	//31
	//F17
	//Unmodified, Shift, Control, Alt
	//
	//
	//32
	//F18
	//Unmodified, Shift, Control, Alt
	//
	//
	//33
	//F19
	//Unmodified, Shift, Control, Alt
	//
	//
	//34
	//F20
	//Unmodified, Shift, Control, Alt
	//
	//
	//
	//
	//Ps2
	//Modifiers in effect
	//
	//
	//
	//
	//0 or omitted
	//none
	//
	//
	//1
	//none
	//
	//
	//2
	//Shift
	//
	//
	//3
	//Alt
	//
	//
	//4
	//Alt + Shift
	//
	//
	//5
	//Control
	//
	//
	//6
	//Control + Shift
	//
	//
	//7
	//Alt + Control
	//
	//
	//8
	//Alt + Control + Shift
	//
	//
	//
	//
	//Notes
	//
	//
	//Shift is not distinguished for the editing and numeric keypad keys by default
	//so it does not interfere with touch typing patterns. This means that shifted
	//keys send the same DECFNK sequence as the unshifted keys.
	//The cursor keys are not available unmodified since they send standard cursor
	//key sequences, not DECFNK sequences.
	//Ctrl with , , Next, and Prev are used for local panning by default.
	//Top row function keys F1 through F5 are only available when they are not
	//used for local terminal functions.
	//Shifted top row function keys F6 through F20 are still reserved for user-defined
	//key sequences. The DECFNK sequences become the factory default
	//UDK sequences for shifted F6 through F20.
	//
	//
	//Format:
	//	CSI Ps1 ;  Ps2 ~
	//	9B  3?  3B 3?  7E
	//
	//Parameters:
	//	0- Ps2indicates the modifier key state.

	DECFRA, FillRectangularArea AnsiEscapeType = iota, iota
	//Fill Rectangular Area (DECFRA)
	//This control function fills a rectangular area in page memory with a specified
	//character. DECFRA replaces the rectangular area's character positions and
	//attributes with the specified fill character. The fill character assumes the visual
	//character attributes set by the last select graphic rendition (SGR) command.
	//DECFRA does not change the current line attributes.
	//
	//
	//
	//Format:
	//	CSI Pch ;  Pt; Pl; Pb; Pr $  x
	//	9B  3n  3B 3n             24 78
	//
	//Parameters:
	//	Pch- is the decimal value of the fill character. Pch can be any value from 32 to 126
	//or from 160 to 255. If Pch is not in this range, then the terminal ignores the
	//DECFRA command. The decimal value refers to the character in the current GL
	//or GR in-use table.

	DECHDPXM, SetResetHalfDuplexMode AnsiEscapeType = iota, iota
	//Set/Reset Half-Duplex Mode (DECHDPXM)
	//Enables half-/full-duplex communication.
	//
	//Full-duplex mode allows simultaneously two-way communication; half-duplex
	//mode is limited to one-way communication at any given time. Half-duplex
	//mode is available only in an RS232 line. Refer to Chapter 9 for details about
	//half-duplex mode communication protocol.
	//
	//Format:
	//	CSI ?  1  0  3  h
	//	9B  3F 31 30 33 68
	//	CSI ?  1  0  3  l
	//	9B  3F 31 30 33 6C
	//

	DECHEBM, HebrewNAKeyboardMapping AnsiEscapeType = iota, iota
	//Hebrew/N-A Keyboard Mapping (DECHEBM)
	//This control function sets the keyboard mapping to Hebrew/N-A and resets the
	//mapping to North American.
	//
	//When 8-bit characters are selected, DECHEBM switches between the Group
	//1 and the Group 2 character set mappings. It does not affect the keyboard
	//character set selection or the processing of received characters.
	//
	//When 7-bit characters are selected or the terminal is set to VT100 mode, setting
	//DECHEBM does the following:
	//
	//
	//Switches keyboard map to Group 2.
	//Makes DEC 7-bit Hebrew the keyboard character set.
	//Causes received characters in the range of 60 to 7A (hex) to be displayed
	//using the DEC 7-bit Hebrew when ASCII is designated or invoked and
	//keyboard Group 2 is active.
	//
	//
	//Resetting DECHEBM does the following:
	//
	//
	//Switches keyboard map to Group 1.
	//Makes ASCII the keyboard character set.
	//Causes received characters to be displayed using the graphic left (GL) table of
	//characters in use at the time.
	//
	//
	//Note
	//DECHEBM is only valid when a Hebrew keyboard language is selected.
	//Also it does not convert ASCII or Hebrew characters already on the
	//display.
	//
	//Format:
	//	CSI ?  3  5  h
	//	9B  3F 33 35 68
	//	CSI ?  3  5  l
	//	9B  3F 33 35 6C
	//
	//Parameters:
	//	When 7-bit characters are selected or the terminal is set to VT100 mode, setting- DECHEBM does the following:

	DECHEM, HebrewEncodingMode AnsiEscapeType = iota, iota
	//Hebrew Encoding Mode (DECHEM)
	//This control function sets the terminal's character set mode to DEC (8-bit)
	//multinational mode. On a reset, the sequence resets the terminal's character set
	//mode to (7-bit) national mode (NRC sets).
	//
	//
	//
	//Format:
	//	CSI ?  3  6  h
	//	9B  3F 33 36 68
	//	CSI ?  3  6  l
	//	9B  3F 33 36 6C
	//

	DECIC, InsertColumn AnsiEscapeType = iota, iota
	//Insert Column (DECIC)
	//This control function inserts one or more columns into the scrolling region,
	//starting with the column that has the cursor.
	//
	//As columns are inserted, the columns between the cursor and the right margin
	//move to the right. DECIC inserts blank columns with no visual character
	//attributes. DECIC has no effect outside the scrolling margins.
	//
	//Format:
	//	CSI Pn '  }
	//	9B  3? 27 7D
	//
	//Parameters:
	//	Pn- is the number of columns to insert.
	//Default: Pn = 1.

	DECINVM, InvokeMacro AnsiEscapeType = iota, iota
	//Invoke Macro (DECINVM)
	//This control function lets you execute a stored macro. You store macros with
	//the define macro (DECDMAC) control string. The terminal substitutes the
	//DECINVM sequence with the contents of the macro definition and executes the
	//macro.
	//
	//
	//
	//Format:
	//	CSI Pid *  z
	//	9B  3n  2A 7A
	//
	//Parameters:
	//	7- To invoke the macro, use the following sequence:	Suppose you want to create a macro that clears all pages in page memory, writes- the word "top" at the top of each page, and leaves the cursor on page 1.	Pid- is the macro ID number. If the Pid is not associated with a particular macro, the
	//terminal ignores the command.	DCS 1 ; 0 ; 1 ! z 9B 36 20 50 ! 6 ; 9B 31 3B 48 9B 32 49 54- 4F 50 9B 31 56 ; ST	DCS 1 ; 0 ; 1 ! z CSI 6 SP P ! 6 ; CSI 1 ; 1 H CSI 2 J TOP- CSI 1 V ; ST	Any functions executed with a macro invocation remain in affect after the- terminal executes the macro.	Then, you must convert the string into hexadecimal code because the string uses- the repeat (!) character. You can only use the repeat character with hexadecimal
	//sequences. The following example is the same string written in hex:	3- First, you would write the string with ASCII characters as follows:

	DECIPEM, EnterReturnfromIBMProPrinterEmulationMode AnsiEscapeType = iota, iota
	//Enter/Return from IBM ProPrinter Emulation Mode (DECIPEM)
	//Exit from DEC protocol and interpret subsequent data according to the IBM
	//ProPrinter protocol syntax. This sequence also resets IBM ProPrinter mode to its
	//initial state.
	//
	//
	//
	//Format:
	//	CSI ?  5  8  h
	//	9B  3F 35 38 68
	//	CSI ?  5  8  l
	//	9B  3F 35 38 6C
	//

	DECKBD, KeyboardLanguageSelection AnsiEscapeType = iota, iota
	//Keyboard Language Selection (DECKBD)
	//Select a national keyboard language on either a VT keyboard or an Enhanced PC
	//keyboard.
	//
	//The first selective parameter, Ps1, denotes a keyboard type, VT layout or
	//Enhanced PC keyboard layout. The second parameter, Ps2, indicates the national
	//keyboard language.
	//
	//Selecting a new keyboard language automatically initializes the keyboard
	//character set. Refer to Chapter 8 for more details.
	//
	//Format:
	//	CSI Ps1 ;  Ps2 SP }
	//	9B  3n  3B 3n  20 7D
	//
	//Parameters:
	//	The first selective parameter, Ps1, denotes a keyboard type, VT layout or- Enhanced PC keyboard layout. The second parameter, Ps2, indicates the national
	//keyboard language.	Ps2- indicates the national keyboard language.

	DECKBUM, TypewriterorDataProcessingKeys AnsiEscapeType = iota, iota
	//Typewriter or Data Processing Keys (DECKBUM)
	//You can select whether the main keyboard keys act as data processing keys or
	//typewriter keys by using the keyboard usage mode (DECKBUM) function.
	//
	//If DECKBUM is set, then data processing keys send the characters on the right
	//half of their keycaps.
	//
	//If DECKBUM is reset, then data processing keys send the characters on the left
	//half of their keycaps.
	//
	//Notes on DECKBUM
	//
	//
	//DECKBUM changes the characters that the main keyboard keys send. Make
	//sure you are aware of this change if you use DECKBUM in an application.
	//If you use the North American language, then DECKBUM should always be
	//reset (typewriter). For all other languages, you can use either mode.
	//
	//
	//Format:
	//	CSI ?  6  8  h
	//	9B  3F 36 38 68
	//	CSI ?  6  8  l
	//	9B  3F 36 38 6C
	//

	DECKLHIM, KeyboardLEDsHostIndicatorMode AnsiEscapeType = iota, iota
	//Keyboard LED's Host Indicator Mode (DECKLHIM)
	//DECKLHIM controls the state of the keyboard LED's host indicator mode.
	//
	//DECLL controls keyboard LEDs independently of any keyboard state. The use
	//of LEDs for this purpose conflicts with their use as keyboard state indicators.
	//DECKLHIM selects a mode of how the keyboard LEDs are to be used: as
	//keyboard indicators; or host indicators. If host indicators is selected, then the
	//DECLL sequence can be used to control the keyboard LEDs.
	//
	//For DECLL to function, DECKLHIM must be set. See DECLL for the
	//implications of using DECLL to control the keyboard LEDs independently of
	//any keyboard state.
	//
	//Format:
	//	CSI ?  1  1  0  h
	//	9B  3F 31 31 30 68
	//	CSI ?  1  1  0  l
	//	9B  3F 31 31 30 6C
	//

	DECKPAM, KeypadApplicationMode AnsiEscapeType = iota, iota
	//Keypad Application Mode (DECKPAM)
	//DECKPAM enables the numeric keypad to send application sequences to the host.
	//DECKPNM enables the numeric keypad to send numeric characters.
	//
	//
	//
	//Format:
	//	ESC =
	//	1B  3D
	//

	DECKPM, KeyPositionMode AnsiEscapeType = iota, iota
	//Key Position Mode (DECKPM)
	//This control function selects whether the keyboard sends character codes or key
	//position reports to the host. DECKPM lets new applications take full control
	//of the keyboard including single shifts, locking shifts, and compose character
	//processing.
	//
	//If the DECKPM function is set, then all keyboard keys send extended reports
	//that include the key position and the state of modifier keys when pressed. A
	//modifier key is pressed in combination with another key to modify the code sent
	//by that key. The Ctrl key is a modifier key.
	//
	//If the DECKPM function is reset, then the keyboard keys send character codes.
	//
	//Note on DECKPM
	//
	//DECKPM only affects keyboard input; it does not affect how the terminal
	//interprets data from the host.
	//
	//Format:
	//	CSI ?  8  1  h
	//	9B  3F 38 31 68
	//	CSI ?  8  1  l
	//	9B  3F 38 31 6C
	//

	DECKPNM, KeypadNumericMode AnsiEscapeType = iota, iota
	//Keypad Numeric Mode (DECKPNM)
	//DECKPNM enables the keypad to send numeric characters to the host.
	//DECKPAM enables the keypad to send application sequences.
	//
	//DECKPNM enables the numeric keypad to send the characters shown on each
	//key&#8212;number, comma, period, or minus sign. Keys PF1 to PF4 send application
	//sequences. See DECKPAM&#8212;Keypad Application Mode for more information.
	//
	//Note on DECKPNM
	//
	//The setting is not saved in NVM. When you turn on or reset the terminal, it
	//automatically selects numeric keypad mode.
	//
	//Format:
	//	ESC &gt;
	//	1B  3E
	//
	//Parameters:
	//	DECKPNM enables the numeric keypad to send the characters shown on each- key&#8212;number, comma, period, or minus sign. Keys PF1 to PF4 send application
	//sequences. See DECKPAM&#8212;Keypad Application Mode for more information.	0- Default: Send numeric keypad characters.
	//
	//Default: Send numeric keypad characters

	DECLANS, LoadAnswerbackMessage AnsiEscapeType = iota, iota
	//Load Answerback Message (DECLANS)
	//This sequence loads an answerback message into the terminal's memory.
	//
	//The answerback data string may consist of from 0 to 30, 7- or 8-bit characters,
	//which are hex pairs in the range 3/0 - 3/9 (0 through 9), 4/1 - 4/6 (A through F),
	//and 6/1 - 6/6 (A through F).
	//
	//Once defined, the message may be stored in the non-volatile memory if Save
	//settings is executed in the Set-Up.
	//
	//The selective parameter denotes the encoding of the answerback message. A "1"
	//is always used for the VT510 indicating answerback is encoded as hex pairs. The
	//sequence is ignored if any number other than "1" is specified in the Ps field.
	//
	//Pressing Ctrl/Break or receiving ENQ code causes the VT510 to transmit the
	//answerback message. In on-line mode, the answerback message is transmitted to
	//the appropriate host port. The answerback is not echoed in local echo and is not
	//"sent" in local mode.
	//
	//The answerback message is transmitted as keyboard data. Any speed restrictions
	//(as set in limited transmit) apply.
	//
	//Format:
	//	DCS Ps v  D . . . D ST
	//	90  3n 76 ...       9C
	//
	//Parameters:
	//	Pressing Ctrl/Break or receiving ENQ code causes the VT510 to transmit the- answerback message. In on-line mode, the answerback message is transmitted to
	//the appropriate host port. The answerback is not echoed in local echo and is not
	//"sent" in local mode.	The selective parameter denotes the encoding of the answerback message. A "1"- is always used for the VT510 indicating answerback is encoded as hex pairs. The
	//sequence is ignored if any number other than "1" is specified in the Ps field.	Once defined, the message may be stored in the non-volatile memory if Save- settings is executed in the Set-Up.

	DECLBAN, LoadBannerMessage AnsiEscapeType = iota, iota
	//Load Banner Message (DECLBAN)
	//DECLBAN loads the banner message to be displayed on the terminal screen at
	//power up.
	//
	//This command only loads the banner message into dynamic memory. It is
	//necessary to do a Save settings in the Set-Up menu to store the banner message
	//in NVM so that it will be displayed at power up.
	//
	//The terminal displays the banner message in double size characters above the
	//Selftest OK message.
	//
	//Format:
	//	DCS Ps r  D . . . D ST
	//	90  3s 72 ...       9C
	//
	//Parameters:
	//	D ... D- is a 30-character string. If a matching Ps value is selected as an encoding
	//method, then you can select to define the string by the characters in the default
	//character set or by hexadecimal pairs.	This command only loads the banner message into dynamic memory. It is- necessary to do a Save settings in the Set-Up menu to store the banner message
	//in NVM so that it will be displayed at power up.

	DECLFKC, LocalFunctionKeyControl AnsiEscapeType = iota, iota
	//Local Function Key Control (DECLFKC)
	//This control function lets you select the action performed by some of the local
	//function keys on the top row of the keyboard:
	//
	//DECLFKC can accept any number of parameter pairs. The terminal executes the
	//parameters in the order in which it receives them.
	//
	//Note on DECLFKC
	//
	//Applications cannot disable the F5 (Break) key using this command. This
	//restriction is required for secure systems, which ensures that the operator has
	//control of the communication line.
	//
	//Format:
	//	CSI Pk1 ;  Pf1 ... Pkn ;  Pfn *  }
	//	9B  3n  3B 3n  ... 3n  3B 3n  2A 7D
	//
	//Parameters:
	//	Pfn- controls the action of the local function key specified by the corresponding Pkn
	//value.	Pkn- is a number from 0 to 4 that corresponds to the local function key affected (F1 to
	//F4). A Pkn value of 0 means that all four keys (F1 through F4) are affected.	DECLFKC can accept any number of parameter pairs. The terminal executes the- parameters in the order in which it receives them.	0- This control function is useful for:

	DECLL, LoadLEDs AnsiEscapeType = iota, iota
	//Load LEDs (DECLL)
	//Load the programmable LEDs on the keyboard according to its parameters.
	//
	//DECLL controls keyboard LEDs independently of any keyboard state. The use
	//of LEDs for this purpose conflicts with their use as keyboard state indicators.
	//DECKLHIM selects a mode of how the keyboard LEDs are to be used: as
	//keyboard indicators; or host indicators. If host indicators is selected, then the
	//DECLL sequence can be used to control the keyboard LEDs.
	//
	//For DECLL to function, DECKLHIM must be set.
	//
	//Format:
	//	CSI Ps q
	//	9B  3n 71
	//

	DECLRMM, LeftRightMarginMode AnsiEscapeType = iota, iota
	//Left Right Margin Mode (DECLRMM)
	//This control function defines whether or not the set left and right margins
	//(DECSLRM) control function can set margins.
	//
	//When DECLRMM is set, DECSLRM can set the left and right margins. All line
	//attributes currently in page memory for the session are set to single width, single
	//height. The terminal ignores any sequences to change the line attributes to
	//double width or double height (DECDWL or DECDHL).
	//
	//When DECLRMM is reset, DECSLRM cannot set the left and right margins.
	//The margins are set to the page borders for every page. The terminal can
	//process sequences to change the line attributes to double width or double height
	//(DECDWL or DECDHL).
	//
	//Format:
	//	CSI ?  6  9  h
	//	9B  3F 36 39 68
	//	CSI ?  6  9  l
	//	9B  3F 36 39 6C
	//

	DECLTOD, LoadTimeofDay AnsiEscapeType = iota, iota
	//Load Time of Day (DECLTOD)
	//This sequence loads the time of day into the terminal's memory. When loaded,
	//the time of day is displayed in the Status line if the Status line is enabled.
	//
	//
	//
	//Format:
	//	CSI Ps1 ;  Ps2 ,  p
	//	9B  3n  3B 3n  2C 70
	//
	//Parameters:
	//	0- The default value is 8, indicating 8:00 a.m.	Ps2- specifies the minutes, which is a 2-digit decimal number between 00 and 59.

	DECMCM, SetResetModemControlMode AnsiEscapeType = iota, iota
	//Set/Reset Modem Control Mode (DECMCM)
	//Enables (set) or disables (reset) modem control.
	//
	//When enabled for the Comm2 connector, no data is transmitted or received
	//unless DSR is asserted. Assertion of DSR alone is sufficient to establish a
	//connection. Loss of DSR causes a disconnect. When DSR is not asserted, no
	//data is transmitted, and incoming receive data is ignored. When DSR is again
	//asserted, the communications state is re-initialized to prepare for the new
	//connection.
	//
	//When enabled for the Comm1 (25-pin EIA) connector, the terminal does not
	//transmit unless CTS is asserted. If a connection has not been established (DSR
	//is deasserted), RLSD is ignored. Transmission and reception may still occur if
	//CTS is asserted. Assertion of CTS with DSR and RLSD asserted indicates a
	//connection has been established. (CTS is checked last.)
	//
	//When Modem Control is disabled, transmission and reception occur regardless
	//of the state of the modem control signal. The terminal communicates using data
	//leads only. DTR and RTS are always asserted except during an operator initiated
	//disconnect sequence, or the input buffer reaches the 64-byte threshold when DTR
	//flow control scheme is selected.
	//
	//Format:
	//	CSI ?  9  9  h
	//	9B  3F 36 36 68
	//	CSI ?  9  9  l
	//	9B  3F 36 36 6C
	//
	//Parameters:
	//	When enabled for the Comm1 (25-pin EIA) connector, the terminal does not- transmit unless CTS is asserted. If a connection has not been established (DSR
	//is deasserted), RLSD is ignored. Transmission and reception may still occur if
	//CTS is asserted. Assertion of CTS with DSR and RLSD asserted indicates a
	//connection has been established. (CTS is checked last.)

	DECMSR, MacroSpaceReport AnsiEscapeType = iota, iota
	//Macro Space Report (DECMSR)
	//DECMSR is the terminal's response to a DSR from the host. DECMSR indicates
	//the number of bytes available for macro definitions.
	//
	//
	//
	//Format:
	//	CSI Pn *  {
	//	9B  3n 3A 7B
	//

	DECNAKB, GreekNAKeyboardMapping AnsiEscapeType = iota, iota
	//Greek/N-A Keyboard Mapping (DECNAKB)
	//This control function sets the keyboard mapping to North American and resets
	//the mapping to Greek/N-A.
	//
	//
	//
	//Format:
	//	CSI ?  5  7  h
	//	9B  3F 35 37 68
	//	CSI ?  5  7  l
	//	9B  3F 35 37 6C
	//

	DECNCSM, SetResetNoClearingScreenOnColumnChange AnsiEscapeType = iota, iota
	//Set/Reset No Clearing Screen On Column Change (DECNCSM)
	//Set/reset the following condition: do not clear the screen whenever the column
	//mode changes.
	//
	//When enabled, a column mode change (either through Set-Up or by the escape
	//sequence DECCOLM) does not clear the screen. When disabled, the column mode
	//change clears the screen as a side effect.
	//
	//This sequence does not affect the column mode change caused by the sequence,
	//DECSCPP.
	//
	//Format:
	//	CSI ?  9  5  h
	//	9B  3F 39 35 68
	//	CSI ?  9  5  l
	//	9B  3F 39 35 6C
	//

	DECNKM, NumericKeypadMode AnsiEscapeType = iota, iota
	//Numeric Keypad Mode (DECNKM)
	//This control function works like the DECKPAM and DECKPNM functions.
	//DECNKM is provided mainly for use with the request and report mode
	//(DECRQM/DECRPM) control functions.
	//
	//
	//
	//Format:
	//	CSI ?  6  6  h
	//	9B  3F 36 36 68
	//	CSI ?  6  6  l
	//	9B  3F 36 36 6C
	//

	DECNRCM, NationalReplacementCharacterSetMode AnsiEscapeType = iota, iota
	//National Replacement Character Set Mode (DECNRCM)
	//Enable operation in 7-bit or 8-bit character mode.
	//
	//The character set mode is reset to 8-bit characters. In 8-bit mode, the terminal
	//operates as a normal level 4 terminal allowing 8-bit controls and using the default
	//character set, which is user-selectable for transmission and reception.
	//
	//Format:
	//	CSI ?  4  2  h
	//	9B  3F 34 32 68
	//	CSI ?  4  2  l
	//	9B  3F 34 32 6C
	//

	DECNULM, SetResetIgnoringNullMode AnsiEscapeType = iota, iota
	//Set/Reset Ignoring Null Mode (DECNULM)
	//Allow Null (NUL) characters to be ignored or buffered at printer port only.
	//
	//When set, the NUL character is discarded on receipt from the host. When reset,
	//the NUL character is passed through to the printer.
	//
	//Format:
	//	CSI ?  1  0  2  h
	//	9B  3F 31 30 32 68
	//	CSI ?  1  0  2  l
	//	9B  3F 31 30 32 6C
	//

	DECNUMLK, NumLockMode AnsiEscapeType = iota, iota
	//Num Lock Mode (DECNUMLK)
	//DECNUMLK controls the state of the keyboard's
	//
	//
	//
	//Format:
	//	CSI ?  1  0  8  h
	//	9B  3F 31 30 38 68
	//	CSI ?  1  0  8  l
	//	9B  3F 31 30 38 6C
	//

	DECOM, OriginMode AnsiEscapeType = iota, iota
	//Origin Mode (DECOM)
	//This control function sets the origin for the cursor. DECOM determines if the
	//
	//
	//When DECOM is set, the home cursor position is at the upper-left corner of the
	//screen, within the margins. The starting point for line numbers depends on the
	//current top margin setting. The cursor cannot move outside of the margins.
	//
	//When DECOM is reset, the home cursor position is at the upper-left corner of the
	//screen. The starting point for line numbers is independent of the margins. The
	//cursor can move outside of the margins.
	//
	//DECOSCNM&#8212;Set/Reset Overscan Mode
	//
	//Sets or resets overscan mode.
	//
	//Default: Overscan disabled (reset).
	//
	//Format
	//
	//
	//
	//
	//CSI9/11
	//?3/15
	//13/1
	//03/0
	//63/6
	//h6/8
	//Enable overscan
	//
	//
	//
	//
	//
	//
	//
	//CSI9/11
	//?3/15
	//13/1
	//03/0
	//63/6
	//l6/12
	//Disable overscan (Default)
	//
	//
	//
	//
	//Description
	//
	//When set, overscan is enabled.
	//
	//Overscan and 72 Hz refresh rate cannot co-exist when the terminal is set to 42 or
	//53 lines per screen. Refer to DECSNLS&#8212;Set Lines Per Screen for details.
	//
	//Format:
	//	CSI ?  6  h
	//	9B  3F 36 68
	//	CSI ?  6  l
	//	9B  3F 36 6C
	//	CSI ?  1  0  6  h
	//	9B  3F 31 30 36 68
	//	CSI ?  1  0  6  l
	//	9B  3F 31 30 36 6C
	//
	//Parameters:
	//	2- Sets or resets overscan mode.	When DECOM is set, the home cursor position is at the upper-left corner of the- screen, within the margins. The starting point for line numbers depends on the
	//current top margin setting. The cursor cannot move outside of the margins.	4- When set, overscan is enabled.	When DECOM is reset, the home cursor position is at the upper-left corner of the- screen. The starting point for line numbers is independent of the margins. The
	//cursor can move outside of the margins.	3- Default: Overscan disabled (reset).
	//
	//Default: Origin is at the upper-left of the screen, independent of margins

	DECPAK, ProgramAlphanumericKey AnsiEscapeType = iota, iota
	//Program Alphanumeric Key (DECPAK)
	//Allow users to reprogram keys to transmit user-preferred alphanumeric codes or
	//to perform user-preferred functions.
	//
	//This sequence programs one or more keys (and their modifiers) to:
	//
	//
	//Transmit desired alphanumeric codes
	//Perform a local function or send user-defined sequence
	//
	//
	//This function works in all the VT modes except in VT52 mode.
	//
	//The memory allocation and deallocation processes (program key lock and
	//unlock process) on the DECPAK are the same as on the DECPFK. Refer to
	//DECPFK&#8212;Program Function Key for details.
	//
	//The data string D...D format is:
	//
	//Key1/HEX Code String/Function #/UDS/UDS Direction;Key2/...;
	//
	//Parameters
	//
	//Keyn
	//is the key station number and slash "/" is a delimiter.
	//
	//HEX code string
	//is the hex character code to be transmitted with each of the seven modifier states.
	//The hex code represents a valid code in the current character set (either 7-bit or
	//8-bit). Use a period "." as a place holder if a modifier combination is not to be
	//defined. Use a minus "-" preceding the hex representation of a diacritical sign if a
	//diacritical mark is to be defined.
	//
	//The terminal always allows the ISO character set to be used for specifying accent
	//marks to DECPAK even when:
	//
	//
	//7-bit NRCs characters are selected
	//The ISO character set is not the user-preferred supplemental character set
	//
	//
	//The corresponding ISO character set would be based on the keyboard language.
	//Refer to Chapter 8 for keyboard information.
	//
	//The position of the diacritical marks within the ISO Latin character sets is as
	//follows:
	//
	//
	//
	//
	//
	//
	//
	//Diacritical Sign
	//Position
	//Available ISO Character Set(s)
	//
	//
	//
	//
	//Circumflex
	//5/14
	//ASCII
	//
	//
	//Grave
	//6/0
	//ASCII
	//
	//
	//Tilde
	//7/14
	//ASCII
	//
	//
	//Dieresis (umlaut)
	//10/8
	//Latin 1, Latin 2, Latin Greek, Latin Turkish
	//
	//
	//Degree (ring)
	//11/0
	//Latin 1, Latin 2, Latin Greek, Latin Turkish
	//
	//
	//Acute
	//11/4
	//Latin 1, Latin 2, Latin Greek, Latin Turkish
	//
	//
	//Cedilla
	//11/8
	//Latin 1, Latin 2, Latin Turkish
	//
	//
	//Macron
	//10/15
	//Latin 1
	//
	//
	//Breve
	//10/2
	//Latin 2
	//
	//
	//Ogonek
	//11/2
	//Latin 2
	//
	//
	//Caron
	//11/7
	//Latin 2
	//
	//
	//Double Acute Accent
	//11/13
	//Latin 2
	//
	//
	//Dot Above
	//15/15
	//Latin 2
	//
	//
	//
	//
	//You should program the Hex string according in the following order:
	//
	//
	//Group 1 unshifted
	//Group 1 shifted
	//Group 1 alternate shifted (Shift 2)
	//Group 2 (Group Shift or Alt Gr) unshifted
	//Group 2 shifted
	//Group 2 alternate shifted
	//Control (if omitted, use default)
	//
	//
	//If the control state is not redefined in this sequence, then the Key/Ctrl combination
	//generates the control code based on the "Group 1 unshifted" state.
	//
	//A graphic key transmits alphanumeric codes only when pressed with the above
	//modifiers. When pressed with Alt key, the graphic key performs either:
	//
	//
	//Local terminal function
	//User-defined sequence (same as UDK)
	//
	//
	//Function #
	//corresponds to a local function to be performed when the key is pressed in
	//combination with the Alt function. Example: Function number "0" is used to
	//make the Key/Alt combination inoperative. Function number "100" indicates
	//a user-defined sequence (UDS), and a UDS direction is defined for the Key/Alt
	//combination following the "/" delimiter.
	//
	//UDS and UDS direction
	//is a user-defined sequence. These parameters are the same as for DECPFK. Refer
	//to DECPFK&#8212;Program Function Key for the details.
	//
	//Once programmed, the key states are not affected by the terminal mode changes.
	//Refer to DECPFK&#8212;Program Function Key for the list of terminal mode changes.
	//
	//Format:
	//	DCS "  y  D . . . D ST
	//	90  22 79 ...       9C
	//
	//Parameters:
	//	The position of the diacritical marks within the ISO Latin character sets is as- follows:	9- You should program the Hex string according in the following order:	Function #- corresponds to a local function to be performed when the key is pressed in
	//combination with the Alt function. Example: Function number "0" is used to
	//make the Key/Alt combination inoperative. Function number "100" indicates
	//a user-defined sequence (UDS), and a UDS direction is defined for the Key/Alt
	//combination following the "/" delimiter.	The memory allocation and deallocation processes (program key lock and- unlock process) on the DECPAK are the same as on the DECPFK. Refer to
	//DECPFK&#8212;Program Function Key for details.	0- This function works in all the VT modes except in VT52 mode.	The corresponding ISO character set would be based on the keyboard language.- Refer to Chapter 8 for keyboard information.	HEX code string- is the hex character code to be transmitted with each of the seven modifier states.
	//The hex code represents a valid code in the current character set (either 7-bit or
	//8-bit). Use a period "." as a place holder if a modifier combination is not to be
	//defined. Use a minus "-" preceding the hex representation of a diacritical sign if a
	//diacritical mark is to be defined.	2- The data string D...D format is:	UDS and UDS direction- is a user-defined sequence. These parameters are the same as for DECPFK. Refer
	//to DECPFK&#8212;Program Function Key for the details.	A graphic key transmits alphanumeric codes only when pressed with the above- modifiers. When pressed with Alt key, the graphic key performs either:	Keyn- is the key station number and slash "/" is a delimiter.	If the control state is not redefined in this sequence, then the Key/Ctrl combination- generates the control code based on the "Group 1 unshifted" state.	3- Key1/HEX Code String/Function #/UDS/UDS Direction;Key2/...;	The terminal always allows the ISO character set to be used for specifying accent- marks to DECPAK even when:

	DECPCCM, PageCursorCouplingMode AnsiEscapeType = iota, iota
	//Page Cursor-Coupling Mode (DECPCCM)
	//This control function determines if a new page appears in the display when the
	//cursor moves to a new page. DECPCCM is only useful with a multiple-page
	//format.
	//
	//When DECPCCM is set, the cursor is coupled to the display when the cursor
	//moves to a new page. The new page appears in the display to keep the cursor in
	//view.
	//
	//When DECPCCM is reset, the cursor is uncoupled from the display. If the cursor
	//moves to a new page, then the cursor disappears.
	//
	//Format:
	//	CSI ?  6  4  h
	//	9B  3F 36 44 68
	//	CSI ?  6  4  l
	//	9B  3F 36 44 6C
	//

	DECPCTERM, EnterExitPCTermorScancodeMode AnsiEscapeType = iota, iota
	//Enter/Exit PCTerm or Scancode Mode (DECPCTERM)
	//DECPCTERM enables you to switch the terminal between VT mode and PCTerm
	//mode, while the terminal is in VT mode. It also enables you to switch the
	//terminal between ASCII character and scancode keycode mode, while the
	//terminal is in SCO Console mode.
	//
	//The character sets selectable with single-digit Ps2 parameters are available for
	//both VT mode and PCTerm mode. If you select one of these character sets for use
	//in PCTerm mode, then you can use the SCS&#8212;Select Character Set command to
	//modify the PCTerm character set.
	//
	//The PC character sets selectable with three-digit Ps2 parameters are available
	//only in PCTerm mode or SCO console emulation. (SCO console uses PC character
	//sets.) If you select one of these PC character sets, then the SCS command to
	//invoke a character set is ignored.
	//
	//
	//
	//
	//
	//
	//Ps2
	//Character Set
	//
	//
	//
	//
	//0 or none
	//No Change
	//
	//
	//1
	//PC Multilingual
	//
	//
	//2
	//PC International
	//
	//
	//3
	//PC Danish/Norwegian
	//
	//
	//4
	//PC Spanish
	//
	//
	//5
	//PC Portuguese
	//
	//
	//6
	//DEC Supplemental
	//
	//
	//7
	//ISO Latin 1
	//
	//
	//8
	//VT character set
	//
	//
	//210
	//PC Greek
	//
	//
	//220
	//PC Spanish
	//
	//
	//437
	//PC International
	//
	//
	//850
	//PC Multilingual
	//
	//
	//852
	//PC Slavic (Latin 2)
	//
	//
	//857
	//PC Turkish
	//
	//
	//860
	//PC Portuguese
	//
	//
	//862
	//PC Hebrew
	//
	//
	//863
	//PC French Canadian
	//
	//
	//865
	//PC Danish
	//
	//
	//866
	//PC Cyrillic
	//
	//
	//
	//
	//Format:
	//	CSI ?  Ps1 ;  Ps2 r
	//	9B  3F 3n  3B 3n  72
	//
	//Parameters:
	//	The character sets selectable with single-digit Ps2 parameters are available for- both VT mode and PCTerm mode. If you select one of these character sets for use
	//in PCTerm mode, then you can use the SCS&#8212;Select Character Set command to
	//modify the PCTerm character set.	Ps2- indicates the character set selection. See SCS&#8212;Select Character Set for the
	//character set designators.

	DECPEX, PrinterExtentMode AnsiEscapeType = iota, iota
	//Printer Extent Mode (DECPEX)
	//This control function selects how much data you can print when you use the print
	//page function.
	//
	//
	//
	//Format:
	//	CSI ?  1  9  h
	//	9B  3F 31 39 68
	//	CSI ?  1  9  l
	//	9B  3F 31 39 6C
	//

	DECPFF, PrintFormFeedMode AnsiEscapeType = iota, iota
	//Print Form Feed Mode (DECPFF)
	//This control function selects whether or not the terminal sends a form feed (FF)
	//character to the printer at the end of a printing function. DECPFF does not affect
	//the print cursor line function described in the next section.
	//
	//
	//
	//Format:
	//	CSI ?  1  8  h
	//	9B  3F 31 38 68
	//	CSI ?  1  8  l
	//	9B  3F 31 38 6C
	//

	DECPFK, ProgramFunctionKey AnsiEscapeType = iota, iota
	//Program Function Key (DECPFK)
	//Used to reprogram function keys.
	//
	//This sequence programs one or more keys (and their modifier combinations) from
	//the current state to perform user-desired functions. The type of the function
	//programmed must be either:
	//
	//
	//a local terminal function
	//a user-defined sequence (same as UDK)
	//
	//
	//This sequence is ignored when the program key function is locked through
	//DECPKA, DECUDK, or Set-Up.
	//
	//There are 804 bytes reserved for programmable key operations. This memory is
	//shared by the following four functions:
	//
	//
	//Program keys through DECPFK or through Set-Up
	//Program keys through DECPAK or through Set-Up
	//Copy other key default through DECCKD or Set-Up
	//Program user-defined keys through DECUDK
	//
	//
	//Space is supplied on a first-come, first-serve basis. Once the 804 bytes are used,
	//no more keys may be redefined unless space is made available. Space may be
	//made available by restoring keys back to their default states. There are four
	//ways to do this:
	//
	//
	//Execute a Restore factory defaults from the Set-Up main menu. All the
	//terminal parameters, including the keys, return to their default states.
	//Execute a "Restore factory defaults of all keys and key definitions" either
	//through DECPKA (Program Key Action) or Recall key definitions in
	//Set-Up. This action also releases the 804 bytes.
	//Execute a Copy key default to copy a key's own default either through
	//DECCKD or in Set-Up to free the space occupied by the destination key.
	//Clear UDKs by issuing a clear function in DECUDK.
	//
	//
	//The free bytes left for key programming can be seen using the Define Key
	//Editor in Set-Up. D ... D are the key definition strings such as:
	//
	//Key1/Mod1/Function #/UDS/UDS Direction;
	//Key2/Mod2/Function #/UDS/UDS Direction;........;
	//
	//Parameters
	//
	//Keyn
	//is the key station number and a slash "/" is a delimiter. Refer to Chapter 8 for
	//the key station number map.
	//
	//Modn
	//denotes the modifier key that is to be pressed at the same time as the defined
	//key.
	//
	//
	//
	//
	//
	//
	//Modn
	//Modifier Key
	//
	//
	//
	//
	//0 or None
	//Normal
	//
	//
	//1
	//Normal
	//
	//
	//2
	//Shift
	//
	//
	//3
	//Alt
	//
	//
	//4
	//Alt + Shift
	//
	//
	//5
	//Control
	//
	//
	//6
	//Shift + Control
	//
	//
	//7
	//Alt + Control
	//
	//
	//8
	//Alt + Control + Shift
	//
	//
	//
	//
	//Function #
	//represents a number associated with a local function. For example, function
	//number "0" is used to make the key or key/modifier inoperative. Function number
	//"100" indicates a user-defined sequence (UDS) and UDS direction is defined
	//following the slash "/" delimiter. Refer to Chapter 8.
	//
	//UDS
	//is a user-defined sequence with a maximum length of 255 bytes, which must be
	//written in Hex format for DEC/ANSI terminals. Each hex code in this string
	//represents a value transmitted by the defined key combined with the modifiers.
	//
	//
	//UDS in DECPFK is functionally equivalent to the string Stn in the DECUDK
	//control function.
	//See DECUDK&#8212;User Defined Keys.
	//
	//
	//Dir (UDS Direction)
	//the user-defined sequence (UDS) direction of the transmission.
	//
	//
	//
	//
	//
	//
	//
	//Dir
	//Direction
	//UDS is sent to . . .
	//
	//
	//
	//
	//0, none
	//Normal
	//Host and/or the terminal, depending on the setting of the
	//COMM mode parameter. The UDS is directed to:
	//
	//The host for full-duplex mode.
	//The screen for half-duplex mode.
	//
	//
	//
	//1
	//Local
	//Terminal screen only.
	//
	//
	//2
	//Remote
	//Host only.
	//
	//
	//
	//
	//Default: None (Normal)
	//
	//Description
	//
	//Any of the following four methods may be used to define a key to transmit a
	//user-defined sequence (either single byte or multiple bytes):
	//
	//
	//Control function DECPFK
	//Control function DECPAK
	//Control function DECUDK
	//In Set-Up, Define key ...
	//
	//
	//Once programmed, the key state is not effected by the terminal mode changes
	//listed below:
	//
	//
	//Keyboard mode change, such as switching between Data Processing mode and
	//Typewriter mode
	//Character Mode change, such as switching between 7-bit character and 8-bit
	//character
	//Keyboard Layout change, such as switching between PC layout and VT layout
	//Keyboard Style change, such as switching between PC-style and VT-style
	//Terminal Mode change, such as switching between VT modes
	//
	//
	//This function works in all the ANSI VT modes except VT52 mode.
	//
	//Format:
	//	DCS "  x  D . . . D ST
	//	90  22 78 ...       9C
	//
	//Parameters:
	//	Space is supplied on a first-come, first-serve basis. Once the 804 bytes are used,- no more keys may be redefined unless space is made available. Space may be
	//made available by restoring keys back to their default states. There are four
	//ways to do this:	UDS- is a user-defined sequence with a maximum length of 255 bytes, which must be
	//written in Hex format for DEC/ANSI terminals. Each hex code in this string
	//represents a value transmitted by the defined key combined with the modifiers.	Key1/Mod1/Function #/UDS/UDS Direction;- Key2/Mod2/Function #/UDS/UDS Direction;........;	Modn- denotes the modifier key that is to be pressed at the same time as the defined
	//key.	Function #- represents a number associated with a local function. For example, function
	//number "0" is used to make the key or key/modifier inoperative. Function number
	//"100" indicates a user-defined sequence (UDS) and UDS direction is defined
	//following the slash "/" delimiter. Refer to Chapter 8.	This sequence is ignored when the program key function is locked through- DECPKA, DECUDK, or Set-Up.	There are 804 bytes reserved for programmable key operations. This memory is- shared by the following four functions:	Once programmed, the key state is not effected by the terminal mode changes- listed below:	The free bytes left for key programming can be seen using the Define Key- Editor in Set-Up. D ... D are the key definition strings such as:	10- Default: None (Normal)	Keyn- is the key station number and a slash "/" is a delimiter. Refer to Chapter 8 for
	//the key station number map.	Dir (UDS Direction)- the user-defined sequence (UDS) direction of the transmission.	Any of the following four methods may be used to define a key to transmit a- user-defined sequence (either single byte or multiple bytes):
	//
	//Default: None (Normal)

	DECPKA, ProgramKeyAction AnsiEscapeType = iota, iota
	//Program Key Action (DECPKA)
	//Allow changes to programmable keys, which affects all the keys on the keyboard
	//in all the VT modes except in VT52 mode.
	//
	//
	//
	//Format:
	//	CSI Ps +  z
	//	9B  3n 2B 7A
	//
	//Parameters:
	//	If the parameter Ps is set to 3, all saved settings of the keys and keys/modifiers- combination are recalled from the NVR.	If the parameter Ps is set to 2, then all the keys and keys/modifiers combination- restore to their factory default states. Refer to DECCKD&#8212;Copy Key Default if
	//restoring defaults for a single key and key/modifier combination.	Once locked, keys can only be unlocked through Set-Up. There is no host control- function that can unlock the keys.	If set to "1," the parameter determines whether the keys will be locked. Any- attempt to program keys will be invalid.	If the keys are not locked, then the keys are available for further definition- either through Set-Up or control functions DECPFK, DECPAK, DECCKD, and
	//DECUDK. But if "Lock UDK" is enabled by DECUDK, then the attempt to
	//program the keys does not take effect. (Refer to DECUDK&#8212;User Defined Keys
	//for details.)

	DECPKFMR, ProgramKeyFreeMemoryReport AnsiEscapeType = iota, iota
	//Program Key Free Memory Report (DECPKFMR)
	//Report the approximate free memory space for program key operations.
	//
	//The VT510 reports this sequence upon receiving DECRQPKFM from the host.
	//
	//Note on DECPKFMR
	//
	//The free bytes reported by Ps2 in this command represents only the approximate
	//amount of memory available, because additional memory is used by the firmware
	//data structure to program the key definitions.
	//
	//Format:
	//	CSI Ps1 ;  Ps2 +  y
	//	9B  3n  3B 3n  2B 79
	//
	//Parameters:
	//	1- The VT510 reports this sequence upon receiving DECRQPKFM from the host.	Ps2- denotes the memory space that is available at the time DECRQPKFM is received,
	//depending on the number of bytes left in decimal format. A "0" indicates that no
	//memory is left for any key programming operation; in which case, any attempt to
	//program the keys will fail.

	DECRARA, ReverseAttributesinRectangularArea AnsiEscapeType = iota, iota
	//Reverse Attributes in Rectangular Area (DECRARA)
	//This control function lets you reverse the visual character attributes (bold, blink,
	//reverse video, and underline) of a specified rectangular area in page memory. The
	//select attribute change extent (DECSACE) control function determines whether
	//all or some of the character positions in the rectangle are affected.
	//
	//
	//
	//Format:
	//	CSI Pt; Pl; Pb; Pr;     Ps1; . . . Psn        $  t
	//	9B  area to be reversed attributes to reverse 24 74
	//
	//Parameters:
	//	The following sequence reverses the blink and underscore attributes of the- complete screen:	Pt, Pl, Pb, and Pr- define the rectangular area to be reversed.	The following sequence reverses all attributes except the blink attribute, from- position line 10, column 2 to position line 14, column 45 on the current page:	6- CSI ; ; ; ; 0; 4; 5; $t	When you use more than one parameter in a command, DECRARA executes them- cumulatively in sequence.	0- Available in: VT Level 4 mode only	Ps1; . . . Psn- select the visual character attributes to reverse. These values correspond to the
	//values used in the select graphic rendition (SGR) function.	3- DECRARA ignores all other parameter values.

	DECRC, RestoreCursor AnsiEscapeType = iota, iota
	//Restore Cursor (DECRC)
	//Restores the terminal to the state saved by the save cursor (DECSC) function.
	//
	//If nothing was saved by DECSC, then DECRC performs the following actions:
	//
	//
	//Moves the cursor to the home position (upper left of screen).
	//Resets origin mode (DECOM).
	//Turns all character attributes off (normal setting).
	//Maps the ASCII character set into GL, and the DEC Supplemental Graphic
	//set into GR.
	//
	//
	//Notes on DECSC and DECRC
	//
	//The terminal maintains a separate DECSC buffer for the main display and the
	//status line. This feature lets you save a separate operating state for the main
	//display and the status line.
	//
	//Format:
	//	ESC 8
	//	1B  38
	//

	DECRLCM, RighttoLeftCopy AnsiEscapeType = iota, iota
	//Right-to-Left Copy (DECRLCM)
	//Perform a copy/paste from right-to-left or from left-to-right.
	//
	//When operating in Copy/Paste, you can paste the copied text according to the
	//direction assigned in this command sequence.
	//
	//If right-to-left copy is selected, then the text is stored in the paste buffer starting
	//from right-to-left. For example if "ABCD" is to be copied right-to-left, when a
	//Paste key is pressed, the string is saved in the paste buffer as "DCBA." Thus, the
	//text is displayed as "DCBA".
	//
	//Format:
	//	CSI ?  9  6  h
	//	9B  3F 39 36 68
	//	CSI ?  9  6  l
	//	9B  3F 39 36 6C
	//

	DECRLM, CursorRighttoLeftMode AnsiEscapeType = iota, iota
	//Cursor Right to Left Mode (DECRLM)
	//This control function starts/stops the right-to-left cursor direction.
	//
	//DECRLM state is common to both the main display and the status line display.
	//The status line is effected only when you set it to Host Writable Status Display
	//in the Display Set-Up screen. DECRLM does not affect column numbering within
	//the line. The first line column is always at the left side of the display window.
	//The last column is always at the right side of the display window.
	//
	//The next character position is defined as the current cursor position minus 1.
	//
	//If the terminal is in Replace mode (IRM is reset), then:
	//
	//
	//The new character is inserted in the current cursor position.
	//The cursor moves to the next character position.
	//
	//
	//If terminal is in Insert mode (IRM is set), then:
	//
	//
	//All characters from the current cursor position to the left margin inclusively
	//are shifted one position towards the left.
	//The character previously displayed at the left margin disappears.
	//The new character is inserted in the current cursor position.
	//The cursor moves to the next character position.
	//
	//
	//The following escape sequences are not affected by the DECRLM setting:
	//
	//
	//
	//
	//ICH - Insert Character
	//DCH - Delete Character
	//ED - Erase in Display
	//EL - Erase in Line
	//DECSED - Selective Erase in Display
	//DECSEL - Selective Erase in Line
	//ECH - Erase Character
	//
	//
	//
	//
	//The following escape sequences are not affected by the DECRLM setting:
	//
	//
	//
	//
	//CUP - Cursor Position
	//HVP - Horizontal and Vertical Position
	//CUF - Cursor Forward
	//CUB - Cursor Backward
	//
	//
	//
	//
	//Notes on DECRLM
	//
	//
	//The BS control character increases the current cursor position by one, thus
	//moving the cursor on the screen one position to the right.
	//When new line mode (LNM) is set and the terminal receives one of the control
	//codes LF, VT, or FF, the cursor moves to the last right-most column of the
	//next line.
	//When control code CR is received, the cursor moves to the last right-most
	//column of the current line.
	//When control code SUB is received, a number of cancellation activities result
	//within the terminal and the terminal displays an error character, according to
	//the current DECRLM setting.
	//When control code NEL is received, the cursor moves to the last right-most
	//column of the next line. If the cursor is at the bottom margin, then the page
	//scrolls up.
	//If auto-wrap is enabled (DECAWM is set), then a graphic character received
	//when the cursor is at column number one appears at the right margin column
	//of the next line. If the cursor is at the end of the scrolling region, then any
	//text already on the page scrolls up.
	//
	//
	//Format:
	//	CSI ?  3  4  h
	//	9B  3F 33 44 68
	//	CSI ?  3  4  l
	//	9B  3F 33 44 6C
	//
	//Parameters:
	//	3- The following escape sequences are not affected by the DECRLM setting:	0- The next character position is defined as the current cursor position minus 1.	1- If the terminal is in Replace mode (IRM is reset), then:	2- If terminal is in Insert mode (IRM is set), then:

	DECRPAK, ReportAllModifiersAlphanumericKeyState AnsiEscapeType = iota, iota
	//Report All Modifiers/Alphanumeric Key State (DECRPAK)
	//This control string is in response to a Request Key Definition (DECRQKD).
	//
	//String D...D has a format same as DECPAK.
	//
	//Parameters
	//
	//D ... D
	//See DECPAK for a description of parameters.
	//
	//Format:
	//	DCS "  ~  D . . . D ST
	//	90  22 7E ...       9C
	//

	DECRPDE, ReportDisplayedExtent AnsiEscapeType = iota, iota
	//Report Displayed Extent (DECRPDE)
	//The terminal sends this control function in response to a request displayed extent
	//(DECRQDE) sequence. DECRPDE indicates how much of the current page is
	//displayed on the screen.
	//
	//
	//
	//Format:
	//	CSI Ph ;  Pw ;  Pml ;  Pmt ;  Pmp ;  "  w
	//	9B  3n 3B 3n 3B 3n  3B 3n  3B 3n  3B 22 77
	//
	//Parameters:
	//	Ph- is the number of lines of the current page displayed excluding the status line.	Pmt- is the line number displayed in the top line.	Pw- is the number of columns of the current page displayed.	Pml- is the column number displayed in the left-most column.

	DECRPFK, ReportFunctionKeyDefinition AnsiEscapeType = iota, iota
	//Report Function Key Definition (DECRPFK)
	//The terminal reports a function key's definition when it receives a DECRQKD.
	//DECRPFK denotes a local function number or a defined sequence, that the target
	//key, which is combined with a specific modifier key, performs or transmits.
	//
	//
	//
	//Format:
	//	DCS "  }  D . . . D ST
	//	90  22 7D ...       9C
	//

	DECRPKT, ReportKeyType AnsiEscapeType = iota, iota
	//Report Key Type (DECRPKT)
	//DECRPKT (from the terminal) is a response to a key type inquiry (DECRQKT).
	//
	//
	//
	//Format:
	//	CSI Ps1 ;  Ps2 ,  v
	//	9B  3n  3B 3n  2C 76
	//

	DECRPM, ReportModeTerminalToHost AnsiEscapeType = iota, iota
	//Report Mode - Terminal To Host (DECRPM)
	//Reports the terminal mode in response to a request mode (DECRQM) function. In
	//the response DECRPM informs the host if a certain mode is set (SM—Set Mode)
	//or reset (RM—Reset Mode).
	//
	//DECRQM, DECRPM, SM, and RM support all the mode settings as follows:
	//
	//
	//Table 5&#8211;6 Settings Supported by DECRQM, DECRPM, RM, and SM
	//
	//
	//
	//
	//
	//
	//ANSI Mode
	//DEC Mode
	//
	//
	//Pa
	//Mnemonic
	//Pd
	//Mnemonic
	//
	//
	//
	//
	//*This mode is always reset in the terminal and cannot be changed.
	//&#8224;When the terminal is set to VT52 mode, DECRQM provides no report.
	//
	//
	//
	//
	//1
	//GATM*
	//?1
	//DECCKM
	//
	//
	//2
	//KAM
	//?2
	//DECANM&#8224;
	//
	//
	//3
	//CRM
	//?3
	//DECOLM
	//
	//
	//4
	//IRM
	//?4
	//DECSCLM
	//
	//
	//5
	//SRTM*
	//?5
	//DECSCNM
	//
	//
	//
	//
	//?6
	//DECOM
	//
	//
	//7
	//VEM*
	//?7
	//DECAWM
	//
	//
	//
	//
	//?8
	//DECARM
	//
	//
	//10
	//HEM*
	//&#8211;
	//&#8211;
	//
	//
	//11
	//PUM*
	//&#8211;
	//&#8211;
	//
	//
	//12
	//SRM
	//&#8211;
	//&#8211;
	//
	//
	//13
	//FEAM*
	//&#8211;
	//&#8211;
	//
	//
	//14
	//FETM*
	//&#8211;
	//&#8211;
	//
	//
	//15
	//MATM*
	//&#8211;
	//&#8211;
	//
	//
	//16
	//TTM*
	//&#8211;
	//&#8211;
	//
	//
	//17
	//SATM*
	//&#8211;
	//&#8211;
	//
	//
	//18
	//TSM*
	//?18
	//DECPFF
	//
	//
	//19
	//EBM*
	//?19
	//DECPEX
	//
	//
	//20
	//LNM
	//&#8211;
	//&#8211;
	//
	//
	//&#8211;
	//&#8211;
	//?25
	//DECTCEM
	//
	//
	//&#8211;
	//&#8211;
	//?34
	//DECRLM
	//
	//
	//&#8211;
	//&#8211;
	//?35
	//DECHEBM
	//
	//
	//&#8211;
	//&#8211;
	//?36
	//DECHEM
	//
	//
	//&#8211;
	//&#8211;
	//?42
	//DECNRCM
	//
	//
	//&#8211;
	//&#8211;
	//?57
	//DECNAKB
	//
	//
	//&#8211;
	//&#8211;
	//?60
	//DECHCCM *
	//
	//
	//&#8211;
	//&#8211;
	//?61
	//DECVCCM
	//
	//
	//&#8211;
	//&#8211;
	//?64
	//DECPCCM
	//
	//
	//&#8211;
	//&#8211;
	//?66
	//DECNKM
	//
	//
	//&#8211;
	//&#8211;
	//?67
	//DECBKM
	//
	//
	//&#8211;
	//&#8211;
	//?68
	//DECKBUM
	//
	//
	//&#8211;
	//&#8211;
	//?69
	//DECLRMM (DECVSSM)
	//
	//
	//&#8211;
	//&#8211;
	//?73
	//DECXRLMM
	//
	//
	//&#8211;
	//&#8211;
	//?95
	//DECNCSM
	//
	//
	//&#8211;
	//&#8211;
	//?96
	//DECRLCM
	//
	//
	//&#8211;
	//&#8211;
	//?97
	//DECCRTSM
	//
	//
	//&#8211;
	//&#8211;
	//?98
	//DECARSM
	//
	//
	//&#8211;
	//&#8211;
	//?99
	//DECMCM
	//
	//
	//&#8211;
	//&#8211;
	//?100
	//DECAAM
	//
	//
	//&#8211;
	//&#8211;
	//?101
	//DECCANSM
	//
	//
	//&#8211;
	//&#8211;
	//?102
	//DECNULM
	//
	//
	//&#8211;
	//&#8211;
	//?103
	//DECHDPXM
	//
	//
	//&#8211;
	//&#8211;
	//?104
	//DECESKM
	//
	//
	//&#8211;
	//&#8211;
	//?106
	//DECOSCNM
	//
	//
	//
	//
	//Format:
	//	CSI Pa ;  Ps $  y  CSI ?  Pd ;  Ps $  y
	//	9B  3n 3B 3n 24 79 9B  3F 3n 3B 3n 24 79
	//
	//Parameters:
	//	7- CSI Ps $ p (or CSI ? Ps $ p (DEC)) (Request Mode)	9- CSI P1.....Pn l (Reset Mode)	1- There are two versions of DECRPM, for ANSI and DEC modes.	Ps- indicates the setting of the mode. The Ps values are the same for the ANSI and
	//DEC versions.	6- The following sequences report the setting for some modes:	Pd- indicates which DEC mode the terminal is reporting on. Table 5&#8211;6 lists the
	//values for Pd.	11- The terminal can only report on one mode at a time.	5- The following sequence reports the setting of a DEC mode:	10- CSI P1.....Pn h (Set Mode)	Pa- Table 5&#8211;6 lists the values for Pa.	This operation is useful for applications that need to temporarily change some of- the terminal's mode settings. When the application is finished, it can restore the
	//mode settings that were in effect before the application changed them. You use
	//the set mode (SM) and reset mode (RM) functions to restore mode settings. SM
	//and RM are described later in this chapter.	8- CSI Ps1; Ps2 $ y (or CSI ? Ps1; Ps2 $ y) (Report Mode)

	DECRPSS, ReportSelectionorSetting AnsiEscapeType = iota, iota
	//Report Selection or Setting (DECRPSS)
	//The terminal sends the host this sequence in response to a request selection or
	//setting (DECRQSS) sequence. The terminal sends DECRPSS to report the setting
	//of a particular control function.
	//
	//
	//
	//Format:
	//	DCS Ps $  r  D ... D ST
	//	90  3n 24 72 ...     9C
	//
	//Parameters:
	//	7- DCS 0 $ r 1 ; 24 r ST	The host requests the setting of the set top and bottom margin function- (DECSTBM). If the current top and bottom margins are set to include the
	//complete screen area (24 lines/screen), then the terminal responds with the
	//following DECRPSS sequence:	D ... D- indicates the current setting of a valid control function that the host asked about.
	//D...D consists of all the characters in the control function, except the CSI (9/11) or
	//ESC [ (1/11, 5/11) introducer characters.	4- DCS 0 $ r 0 ; 4 ; 5 ; 7 m ST	Ps- indicates whether or not the request from the host is valid.	The host requests the setting of the select graphic rendition (SGR) function.- If the current graphic rendition is underline, blinking, and reverse, then the
	//terminal responds with the following DECRPSS sequence:	The host requests the setting of a function that the terminal does not recognize.- The terminal responds with the following DECRPSS sequence:	The terminal does not send a data string (D...D) to the host when the terminal- receives an invalid request.	5- 0 ; 4 ; 5 ; 7 m are all the characters in the SGR sequence, except CSI.	10- DCS 1 $ r ST	This operation is useful for applications that need to temporarily change the- settings of some of the terminal's control functions. When the application is
	//finished, it can restore the control functions to their previous state.	8- 1 ; 24 r are all the characters in the DECSTBM sequence, except CSI.

	DECRPTUI, ReportTerminalUnitID AnsiEscapeType = iota, iota
	//Report Terminal Unit ID (DECRPTUI)
	//DECRPTUI is a response from the terminal to a tertiary DA (DA3) request from
	//the host. DECRPTUI is available in VT Level 4 mode only. See DA3 for more
	//information.
	//
	//
	//
	//Format:
	//	DCS !  |  D . . . D ST
	//	90  21 7C ...       9C
	//

	DECRQCRA, RequestChecksumofRectangularArea AnsiEscapeType = iota, iota
	//Request Checksum of Rectangular Area (DECRQCRA)
	//This control function requests a checksum of the specified rectangular area in the
	//specified page. The terminal returns a checksum report (DECCKSR) in response
	//to this request.
	//
	//
	//
	//Format:
	//	CSI Pid ;  Pp ;  Pt;Pl;Pb;Pr *  y
	//	9B  3n  3B 3n 3B 3n . . . 3n 2A 79
	//
	//Parameters:
	//	Pp- is the page number that has the rectangular area. If Pp is 0 or omitted, then the
	//terminal ignores the following parameters and reports a checksum for all pages
	//in page memory. If Pp is a higher number than the number of pages available,
	//then the terminal reports on the last page.	Pt;Pl;Pb;Pr- are the top, left, bottom, and right borders of the rectangular area. Pt and Pb
	//are line numbers. Pt must be less than or equal to Pb. Pl and Pr are column
	//numbers. Pl must be less than or equal to Pr.	Defaults are Pt = 1, Pb = current page length, Pr = current page width. If these- parameters are omitted, then the terminal returns a checksum of page Pp.

	DECRQDE, RequestDisplayedExtent AnsiEscapeType = iota, iota
	//Request Displayed Extent (DECRQDE)
	//The host sends a DECRQDE to the terminal requesting how much of the current
	//page is displayed on the screen for the active session.
	//
	//
	//
	//Format:
	//	CSI "  v
	//	9B  22 76
	//

	DECRQKD, RequestKeyDefinition AnsiEscapeType = iota, iota
	//Request Key Definition (DECRQKD)
	//DECRQKD allows you to inquire about the terminal's definition of:
	//
	//
	//
	//Format:
	//	CSI Ps1 ;  Ps2 ,  w
	//	9B  3n  3B 3n  2C 77
	//
	//Parameters:
	//	Ps1- indicates is the target key's station number. When inquiring for an alphanumeric
	//key definition, Ps2 is ignored by the terminal. DECRPAK always reports
	//a hexadecimal string in which each hexadecimal code represents a value
	//transmitted by pressing a combination of the target key and a modifier key. The
	//whole sequence is ignored if you enter an invalid key/modifier. See DECRPAK.

	DECRQKT, KeyTypeInquiry AnsiEscapeType = iota, iota
	//Key Type Inquiry (DECRQKT)
	//The host issues a DECRQKT to the terminal for the key definition of a function
	//or alphanumeric key. Upon receiving the request, the terminal reports using
	//DECRPKT.
	//
	//
	//
	//Format:
	//	CSI Ps ,  u
	//	9B  3n 2C 75
	//

	DECRQM, RequestModeHostToTerminal AnsiEscapeType = iota, iota
	//Request Mode - Host To Terminal (DECRQM)
	//The host sends this control function to find out if a particular mode is set or reset.
	//The terminal responds with a report mode function (DECRPM—Report Mode - Terminal
	//To Host).
	//
	//
	//
	//Format:
	//	CSI Pa $  p  CSI ?  Pd $  p
	//	9B  3n 24 70 9B  3F 3n 24 70
	//
	//Parameters:
	//	Pa- indicates the ANSI mode that the host is asking about. Table 5&#8211;7 lists the values
	//for Pa.	2- The following sequences request the setting of some ANSI modes:	Pd- indicates the DEC mode the host is asking about. Table 5&#8211;8 lists the values for
	//Pd.

	DECRQPKFM, ProgramKeyFreeMemoryInquiry AnsiEscapeType = iota, iota
	//Program Key Free Memory Inquiry (DECRQPKFM)
	//Inquire as to the amount of free memory for programmable key operations.
	//
	//Upon receiving of this sequence, the terminal responds with DECPKFMR.
	//
	//Format:
	//	CSI +  x
	//	9B  2B 78
	//

	DECRQPSR, RequestPresentationStateReport AnsiEscapeType = iota, iota
	//Request Presentation State Report (DECRQPSR)
	//The host sends this sequence to request a cursor information report (DECCIR) or
	//tabulation stop report (DECTABSR).
	//
	//
	//
	//Format:
	//	CSI Ps $  w
	//	9B  3n 24 77
	//

	DECRQSS, RequestSelectionorSetting AnsiEscapeType = iota, iota
	//Request Selection or Setting (DECRQSS)
	//The host requests the terminal setting. See DECRPSS for the terminal's
	//response.
	//
	//DECRQSS (and DECRPSS) support the following settings or selections:
	//
	//
	//
	//
	//
	//
	//
	//Setting
	//Mnemonic
	//Final Character(s)
	//
	//
	//
	//
	//Select Active Status Display
	//DECSASD
	//$ }
	//
	//
	//Select Attribute Change Extent
	//DECSACE
	//* x
	//
	//
	//Set Character Attribute
	//DECSCA
	//" q
	//
	//
	//Set Conformance Level
	//DECSCL
	//" p
	//
	//
	//Set Columns Per Page
	//DECSCPP
	//$ |
	//
	//
	//Set Lines Per Page
	//DECSLPP
	//t
	//
	//
	//Set Number of Lines per Screen
	//DECSNLS
	//* |
	//
	//
	//Set Status Line Type
	//DECSSDT
	//$ ~
	//
	//
	//Set Left and Right Margins
	//DECSLRM
	//s
	//
	//
	//Set Top and Bottom Margins
	//DECSTBM
	//r
	//
	//
	//Set Graphic Rendition
	//SGR
	//m
	//
	//
	//Select Set-Up Language
	//DECSSL
	//p
	//
	//
	//Select Printer Type
	//DECSPRTT
	//$ s
	//
	//
	//Select Refresh Rate
	//DECSRFR
	//" t
	//
	//
	//Select Digital Printed Data Type
	//DECSDPT
	//( p
	//
	//
	//Select ProPrinter Character Set
	//DECSPPCS
	//* p
	//
	//
	//Select Communication Speed
	//DECSCS
	//* r
	//
	//
	//Select Communication Port
	//DECSCP
	//* u
	//
	//
	//Set Scroll Speed
	//DECSSCLS
	//SP p
	//
	//
	//Set Cursor Style
	//DECSCUSR
	//SP q
	//
	//
	//Set Key Click Volume
	//DECSKCV
	//SP r
	//
	//
	//Set Warning Bell Volume
	//DECSWBV
	//SP t
	//
	//
	//Set Margin Bell Volume
	//DECSMBV
	//SP u
	//
	//
	//Set Lock Key Style
	//DECSLCK
	//SP v
	//
	//
	//Select Flow Control Type
	//DECSFC
	//* s
	//
	//
	//Select Disconnect Delay Time
	//DECSDDT
	//$ q
	//
	//
	//Set Transmit Rate Limit
	//DECSTRL
	//" u
	//
	//
	//Set Port Parameter
	//DECSPP
	//+ w
	//
	//
	//
	//
	//Format:
	//	DCS $  q  D . . . D ST
	//	90  24 71 ...       9C
	//

	DECRQTSR, RequestTerminalStateReport AnsiEscapeType = iota, iota
	//Request Terminal State Report (DECRQTSR)
	//The host requests the terminal to report its state. The terminal reports
	//(DECTSR) by indicating the setting of many device attributes. See DECTSR.
	//
	//
	//
	//Format:
	//	CSI Ps $  u
	//	9B  3n 24 75
	//
	//Parameters:
	//	0- DCS 1 $ S D . . . D ST

	DECRQUPSS, UserPreferredSupplementalSet AnsiEscapeType = iota, iota
	//User-Preferred Supplemental Set (DECRQUPSS)
	//Applications can ask for the current user-preferred supplemental set. The
	//terminal responds with the user-preferred supplemental set (DECAUPSS)
	//sequence.
	//
	//
	//
	//Format:
	//	CSI &amp; u
	//	9B  26    75
	//
	//Parameters:
	//	The host requests the current user-preferred supplemental set by sending the- following sequence:

	DECRSPS, RestorePresentationState AnsiEscapeType = iota, iota
	//Restore Presentation State (DECRSPS)
	//This control function restores the terminal to a previous state based on one of the
	//presentation state reports. There are two presentation state reports.
	//
	//
	//
	//Format:
	//	DCS Ps $  t  D ... D ST
	//	90  3n 24 74 ...     9C
	//
	//Parameters:
	//	Programming Tip- Applications can use DECRSPS to restore the terminal to a previous state
	//specified in a presentation state report. See the previous "Cursor Information
	//Report (DECCIR)" section in this chapter.	D ... D- is a data string that contains the restored information. This string is identical to
	//the data string used in the report you are restoring&#8211; Cursor Information Report
	//(DECCIR) or Tab Stop Report (DECTABSR).	The following DECRSPS sequence restores tab stops according to the tab stop- report (DECTABSR):	4- DCS 2 $ t 9/ 17/ 25/ 33/ 41/ 49/ 57/ 65/ 73 ST	Ps- indicates the format of the data string (D . . . D). You can use one of the two
	//following formats for the data string. These formats correspond to the formats
	//used in the two presentation state reports (DECPSR). Make sure you use the
	//format of the report you are restoring.

	DECRSTS, RestoreTerminalState AnsiEscapeType = iota, iota
	//Restore Terminal State (DECRSTS)
	//This sequence restores the terminal to a previous state specified in a terminal
	//state report (DECTSR).
	//
	//
	//
	//Format:
	//	DCS Ps $  p  D . . . D ST
	//	90  3n 24 70 ...       9C
	//
	//Parameters:
	//	Ps- indicates the format of the data string (D . . . D).

	DECSACE, SelectAttributeChangeExtent AnsiEscapeType = iota, iota
	//Select Attribute Change Extent (DECSACE)
	//This control function lets you select which character positions in a rectangle can
	//have their attributes changed or reversed. DECSACE controls the effect of two
	//other functions—change attributes in rectangular area (DECCARA) and reverse
	//attributes in rectangular area (DECRARA).
	//
	//
	//
	//Format:
	//	CSI Ps *  x
	//	9B  3n 2A 78
	//

	DECSASD, SelectActiveStatusDisplay AnsiEscapeType = iota, iota
	//Select Active Status Display (DECSASD)
	//DECSASD selects whether the terminal sends data to the main display or the
	//status line.
	//
	//
	//
	//Format:
	//	CSI Ps $  }
	//	9B  3n 24 7D
	//
	//Parameters:
	//	0- Default: Main display
	//
	//Default: Main display

	DECSCA, SelectCharacterProtectionAttribute AnsiEscapeType = iota, iota
	//Select Character Protection Attribute (DECSCA)
	//DECSCA defines the characters that come after it as erasable or not erasable
	//from the screen. The selective erase control functions (DECSED and DECSEL)
	//can only erase characters defined as erasable.
	//
	//
	//
	//Format:
	//	CSI Ps "  q
	//	9B  3n 22 71
	//
	//Parameters:
	//	Ps- defines all characters that follow the DECSCA function as erasable or not
	//erasable.

	DECSCLM, ScrollingMode AnsiEscapeType = iota, iota
	//Scrolling Mode (DECSCLM)
	//This control function selects the way the terminal scrolls lines. You can select one
	//of two scroll settings, smooth or jump.
	//
	//When DECSLM is set, the terminal adds lines to the screen at a moderate,
	//smooth rate. You can select a slow rate or fast rate in Display Set-Up.
	//
	//When DECSLM is reset, the terminal can add lines to the screen as fast as it
	//receives them.
	//
	//Format:
	//	CSI ?  4  h
	//	9B  3F 34 68
	//	CSI ?  4  l
	//	9B  3F 34 6C
	//

	DECSCL, SelectConformanceLevel AnsiEscapeType = iota, iota
	//Select Conformance Level (DECSCL)
	//You select the terminal's operating level by using the following select conformance
	//level (DECSCL) control sequences. The factory default is level 4 (VT Level 4
	//mode, 7-bit controls).
	//
	//
	//
	//Format:
	//

	DECSCNM, ScreenModeLightorDarkScreen AnsiEscapeType = iota, iota
	//Screen Mode: Light or Dark Screen (DECSCNM)
	//This control function selects a dark or light background on the screen.
	//
	//When DECSCNM is set, the screen displays dark characters on a light
	//background.
	//
	//When DECSCNM is reset, the screen displays light characters on a dark
	//background.
	//
	//Note on DECSCNM
	//
	//Screen mode only effects how the data appears on the screen. DECSCNM does
	//not change the data in page memory.
	//
	//Format:
	//	CSI ?  5  h
	//	9B  3F 35 68
	//	CSI ?  5  l
	//	9B  3F 35 6C
	//

	DECSCPP, Select80or132ColumnsperPage AnsiEscapeType = iota, iota
	//Select 80 or 132 Columns per Page (DECSCPP)
	//There are two control functions that can set the page width to 80 or 132 columns,
	//DECSCPP and DECCOLM (DECCOLM—Select 80 or 132 Columns per Page).
	//
	//
	//
	//Format:
	//

	DECSCP, SelectCommunicationPort AnsiEscapeType = iota, iota
	//Select Communication Port (DECSCP)
	//Select the port to be used for printer or host connection.
	//
	//
	//
	//Format:
	//	CSI Ps1 ;  Ps2 *  u
	//	9B  3n  3B 3n  2A 75
	//
	//Parameters:
	//	Ps2- indicates the port selection for a host connection. Since the VT510 is a single
	//session terminal, the host session can connect to the Comm1 port or the Comm2
	//port.

	DECSCS, SelectCommunicationSpeed AnsiEscapeType = iota, iota
	//Select Communication Speed (DECSCS)
	//Select a communication speed for a communication line.
	//
	//
	//
	//Format:
	//	CSI Ps1 ;  Ps2 *  r
	//	9B  3n  3B 3n  2A 72
	//
	//Parameters:
	//	Ps2- indicates the communication speed.

	DECSCUSR, SetCursorStyle AnsiEscapeType = iota, iota
	//Set Cursor Style (DECSCUSR)
	//Select the style of the cursor on the screen.
	//
	//
	//
	//Format:
	//	CSI Ps SP q
	//	9B  3n 20 71
	//
	//Parameters:
	//	This sequence causes the cursor to be displayed in a different style when the- cursor is enabled.

	DECSC, SaveCursor AnsiEscapeType = iota, iota
	//Save Cursor (DECSC)
	//Saves the following items in the terminal's memory:
	//
	//Saves the following items in the terminal's memory:
	//
	//
	//Cursor position
	//Character attributes set by the SGR command
	//Character sets (G0, G1, G2, or G3) currently in GL and GR
	//Wrap flag (autowrap or no autowrap)
	//State of origin mode (DECOM)
	//Selective erase attribute
	//Any single shift 2 (SS2) or single shift 3 (SS3) functions sent
	//
	//
	//Format:
	//	ESC 7
	//	1B  37
	//

	DECSDDT, SelectDisconnectDelayTime AnsiEscapeType = iota, iota
	//Select Disconnect Delay Time (DECSDDT)
	//Select an appropriate disconnect delay time.
	//
	//The disconnect delay feature determines the time allowed before the terminal
	//disconnects from the communications line when the Received Line Signal Detect
	//(RLSD) is lost.
	//
	//All countries except the United Kingdom should use the 2 seconds delay. The 60
	//ms delay is for use in the United Kingdom.
	//
	//If the terminal detects a loss of carrier and if the user has selected "no
	//disconnect," then the terminal ignores RLSD (CD) after the beginning of the
	//connection.
	//
	//If the user tries to disconnect and reconnect the line, then the terminal checks
	//if RLSD is asserted before granting the connection. Once it is connected, the
	//terminal ignores the loss of carrier. In this case, the disconnect should be done on
	//DSR going off.
	//
	//Format:
	//	CSI Ps $  q
	//	9B  3n 24 71
	//

	DECSDPT, SelectDigitalPrintedDataType AnsiEscapeType = iota, iota
	//Select Digital Printed Data Type (DECSDPT)
	//Allow users to match the characters printed to the character sets the DEC ANSI
	//conforming printer is capable of supporting.
	//
	//This sequence takes effect only when a ProPrinter or DEC printer with ProPrinter
	//emulation mode is attached.
	//
	//Format:
	//	CSI Ps )  p
	//	9B  3n 29 70
	//

	DECSED, SelectiveEraseDisplay AnsiEscapeType = iota, iota
	//Selective Erase Display (DECSED)
	//This control function erases some or all of the erasable characters in the display.
	//DECSED can only erase characters defined as erasable by the DECSCA control
	//function. DECSED works inside or outside the scrolling margins.
	//
	//
	//
	//Format:
	//	CSI ?  Ps J
	//	9B  3F 3n 4A
	//

	DECSEL, SelectiveEraseLine AnsiEscapeType = iota, iota
	//Selective Erase Line (DECSEL)
	//This control function erases some or all of the erasable characters in a single line
	//of text. DECSEL erases only those characters defined as erasable by the DECSCA
	//control function. DECSEL works inside or outside the scrolling margins.
	//
	//
	//
	//Format:
	//	CSI ?  Ps K
	//	9B  3F 3n 4B
	//

	DECSERA, SelectiveEraseRectangularArea AnsiEscapeType = iota, iota
	//Selective Erase Rectangular Area (DECSERA)
	//This control function erases all erasable characters from a specified rectangular
	//area in page memory. The select character protection attribute (DECSCA) control
	//function defines whether or not DECSERA can erase characters.
	//
	//
	//
	//Format:
	//	CSI Pt ;  Pl ;  Pb ;  Pr $  {
	//	9B  3n 3B 3n 3B 3n 3B 3n 24 7B
	//
	//Parameters:
	//	0- Available in: VT Level 4 mode only

	DECSFC, SelectFlowControl AnsiEscapeType = iota, iota
	//Select Flow Control (DECSFC)
	//Select a flow control scheme for the communication port or printer port.
	//
	//
	//
	//Format:
	//	CSI Ps1 ;  Ps2 ;  Ps3 ;  Ps4 *  s
	//	9B  3n  3B 3n  3B 3n  3B 3n  2A 73
	//
	//Parameters:
	//	Ps3- is for the flow control type. When the terminal is in PCTerm mode, XPC replaces
	//XON/XOFF on the receive side.	Ps4- sets the flow control threshold.	Ps2- indicates the flow method. On the VT510, the transmit side or the receive side of
	//the communication line can select different or the same flow control methods.	3- The terminal uses "low" and "high" to denote the flow control threshold.

	DECSKCV, SetKeyClickVolume AnsiEscapeType = iota, iota
	//Set Key Click Volume (DECSKCV)
	//Set the keyclick volume.
	//
	//
	//
	//Format:
	//	CSI Ps SP r
	//	9B  3n 20 72
	//

	DECSLCK, SetLockKeyStyle AnsiEscapeType = iota, iota
	//Set Lock Key Style (DECSLCK)
	//Allow user to select a Lock key style.
	//
	//
	//
	//Format:
	//	CSI Ps SP v
	//	9B  3n 20 76
	//

	DECSLPP, SetLinesPerPage AnsiEscapeType = iota, iota
	//Set Lines Per Page (DECSLPP)
	//This control function sets the number of lines for each page in page memory.
	//
	//If the number of lines specified is not one of the values supported by the
	//implementation, then the next higher supported number of lines per page
	//is assumed. If the number of lines specified exceeds the maximum number
	//supported, then the maximum number supported is used. The valid Pn values
	//are 24, 25, 36, 41, 42, 48, 52, 53, and 72.
	//
	//The VT510 supports three pages of off-screen memory in the following
	//configurations:
	//
	//
	//3 pages &#215; 24 lines (default)
	//2 pages &#215; 25 lines
	//2 pages &#215; 36 lines
	//1 pages &#215; 41 lines
	//1 pages &#215; 42 lines
	//1 pages &#215; 48 lines
	//1 pages &#215; 52 lines
	//1 pages &#215; 53 lines
	//1 pages &#215; 72 lines
	//
	//
	//Notes on DECSLPP
	//
	//
	//If you switch to a smaller page size, then data that was on the larger page
	//may be split across the smaller pages. To avoid confusion, make sure you set
	//the lines/page before you enter data into page memory.
	//DECSLPP usually does not change the top and bottom scrolling margins.
	//If, however, you change the page size so that the current scrolling margins
	//exceed the new page size, then the terminal resets the margins to the page
	//limits.
	//
	//
	//Format:
	//	CSI Pn t
	//	9B  3n 74
	//
	//Parameters:
	//	Pn- Sets the lines per page according to the numeric parameter.	If the number of lines specified is not one of the values supported by the- implementation, then the next higher supported number of lines per page
	//is assumed. If the number of lines specified exceeds the maximum number
	//supported, then the maximum number supported is used. The valid Pn values
	//are 24, 25, 36, 41, 42, 48, 52, 53, and 72.
	//
	//Default: One session—6 pages of 24 lines

	DECSLRM, SetLeftandRightMargins AnsiEscapeType = iota, iota
	//Set Left and Right Margins (DECSLRM)
	//This control function sets the left and right margins to define the scrolling region.
	//DECSLRM only works when vertical split screen mode (DECLRMM) is set.
	//
	//
	//
	//Format:
	//	CSI Pl ;  Pr s
	//	9B  3n 3B 3n 73
	//
	//Parameters:
	//	0- Default: Margins are at the left and right page borders.	Pl- is the column number for the left margin.
	//Default: Pl = 1.
	//
	//Default: Margins are at the left and right page borders

	DECSMBV, SetMarginBellVolume AnsiEscapeType = iota, iota
	//Set Margin Bell Volume (DECSMBV)
	//Set the margin bell volume.
	//
	//This sequence is used to adjust the warning bell volume, which sounds as the
	//current position nears the right margin.
	//
	//Format:
	//	CSI Ps SP u
	//	9B  3n 20 75
	//

	DECSMKR, SelectModifierKeyReporting AnsiEscapeType = iota, iota
	//Select Modifier Key Reporting (DECSMKR)
	//Program the modifier keys to send extended keyboard reports when pressed or
	//released. DECSMKR only works when key position mode (DECKPM) is set.
	//Applications can use DECSMKR to gain more control over the keyboard by
	//monitoring the action of each modifier key.
	//
	//DECSMKR can accept any number of parameter pairs. The terminal executes the
	//parameters in the order in which it receives them. Applications cannot change
	//the function of the F5 (Break) key. This restriction is required for secure systems
	//to ensure that the operator has control of the communication line.
	//
	//Format:
	//	CSI Pm1 ;  Pf1 ... Pmn ;  Pfn +  r
	//	9B  3n  3B 3n  ... 3n  3B 3n  2B 72
	//
	//Parameters:
	//	Pfn- controls the action of the modifier key specified by the corresponding Pmn value.

	DECSNLS, SetLinesPerScreen AnsiEscapeType = iota, iota
	//Set Lines Per Screen (DECSNLS)
	//Set the maximum lines that can be displayed on the screen.
	//
	//The terminal supports three different font heights, which allows 26, 42, or 53
	//data lines to be displayed on the screen or 25, 41, or 52 data lines to be displayed
	//on the screen, plus a status line. The different character fonts are:
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//80/26
	//132/26
	//80/42
	//132/42
	//80/53
	//132/53
	//
	//
	//
	//
	//Cell Width
	//10
	//6
	//10
	//6
	//10
	//6
	//
	//
	//Cell Height
	//16
	//16
	//10
	//10
	//8
	//8
	//
	//
	//
	//
	//Notes on DECSNLS
	//
	//
	//When 26 Line per Screen/72 Hz/Overscan is selected, the cell size changes
	//from 10&#160;&#215;&#160;16 (6&#160;&#215;&#160;16) to 10&#160;&#215;&#160;13 (6&#160;&#215;&#160;13).
	//When 42 lines or 53 lines are selected, users can only select either overscan
	//feature or 72 Hz refresh rate, not both.
	//
	//
	//Valid Combinations
	//
	//The terminal has the following valid combinations:
	//
	//
	//
	//
	//
	//
	//
	//Lines Per Screen
	//Refresh Rate
	//Overscan
	//
	//
	//
	//
	//26
	//72 Hz
	//No
	//
	//
	//26
	//72 Hz
	//Yes
	//
	//
	//26
	//60 Hz
	//No
	//
	//
	//26
	//60 Hz
	//Yes
	//
	//
	//42
	//72 Hz
	//No
	//
	//
	//42
	//60 Hz
	//No
	//
	//
	//42
	//60 Hz
	//Yes
	//
	//
	//53
	//72 Hz
	//No
	//
	//
	//53
	//60 Hz
	//No
	//
	//
	//53
	//60 Hz
	//Yes
	//
	//
	//
	//
	//If an invalid combination is selected, the terminal automatically returns to a
	//valid combination according to the following priority order:
	//
	//
	//Lines Per Screen
	//Refresh Rate
	//Overscan
	//
	//
	//Examples
	//
	//The current combination is 26 lines/72 Hz/Overscan. If you attempt to assign 42
	//lines per screen, then the terminal becomes 42 lines/72 Hz/No Overscan.
	//
	//The current combination is 42 lines/60 Hz/Overscan. If you attempt to assign 72
	//Hz refresh rate, then the terminal becomes 42 lines/72 Hz/No Overscan.
	//
	//The current combination is 53 lines/72 Hz/No Overscan. Any attempt to enable
	//Overscan is invalid.
	//
	//Format:
	//	CSI Pn *  |
	//	9B  3n 2A 7C
	//
	//Parameters:
	//	The current combination is 42 lines/60 Hz/Overscan. If you attempt to assign 72- Hz refresh rate, then the terminal becomes 42 lines/72 Hz/No Overscan.	The current combination is 26 lines/72 Hz/Overscan. If you attempt to assign 42- lines per screen, then the terminal becomes 42 lines/72 Hz/No Overscan.	0- The terminal has the following valid combinations:	If an invalid combination is selected, the terminal automatically returns to a- valid combination according to the following priority order:

	DECSPPCS, SelectProPrinterCharacterSet AnsiEscapeType = iota, iota
	//Select ProPrinter Character Set (DECSPPCS)
	//Allow users to match the characters printed to the character sets the IBM
	//ProPrinter is capable of supporting.
	//
	//This sequence takes affect only when a ProPrinter or DEC printer with
	//ProPrinter emulation mode is attached.
	//
	//Format:
	//	CSI Pn *  p
	//	9B  3n 2A 70
	//

	DECSPP, SetPortParameter AnsiEscapeType = iota, iota
	//Set Port Parameter (DECSPP)
	//Configures communication parameters for either a communication port or a
	//printer port.
	//
	//
	//
	//Format:
	//	CSI Ps1 ;  Ps2 ;  Ps3 ;  Ps4 +  w
	//	9B  3n  3B 3n  3B 3n  3B 3n  2B 77
	//
	//Parameters:
	//	Ps3- determines the parity.	2- Ps3 selections 4 and 5 are not available for the printer port.	Ps2- determines the data bit.

	DECSPRTT, SelectPrinterType AnsiEscapeType = iota, iota
	//Select Printer Type (DECSPRTT)
	//Allow users to select a printer type that matches their environment.
	//
	//Printer type "DEC ANSI" indicates a printer type that is capable of recognizing
	//the attached Digital ANSI conforming escape sequences.
	//
	//"ProPrinter" indicates an attached printer type that recognizes the IBM
	//ProPrinter escape sequences.
	//
	//If the attached printer is an ANSI-compatible printer that has the IBM
	//ProPrinter emulation feature, then select "DEC + IBM."
	//
	//Format:
	//	CSI Ps $  s
	//	9B  3n 24 73
	//

	DECSRC, SecureResetConfirmation AnsiEscapeType = iota, iota
	//Secure Reset Confirmation (DECSRC)
	//The terminal returns this report to the host if the
	//
	//
	//
	//Format:
	//	CSI Pr *  q
	//	9B  3n 2A 71
	//

	DECSRFR, SelectRefreshRate AnsiEscapeType = iota, iota
	//Select Refresh Rate (DECSRFR)
	//Selects a refresh rate.
	//
	//The terminal can be set to refresh its display at the power line frequency in
	//electrically noisy environments. Normally this is unnecessary. The 72 Hz refresh
	//rate is preferred to minimize flicker.
	//
	//Because of a hardware limitation, overscan and 72 Hz refresh rate cannot co-exist
	//when the lines per screen is set to 42 or 53. See DECSNLS for details. If a
	//combination of lines per screen, refresh rate, and overscan become invalid, then
	//the terminal returns to a valid combination in this order of priority:
	//
	//
	//Lines Per Screen
	//Refresh Rate
	//Overscan
	//
	//
	//Format:
	//	CSI Ps "  t
	//	9B  3n 22 74
	//

	DECSR, SecureReset AnsiEscapeType = iota, iota
	//Secure Reset (DECSR)
	//This control function sets the terminal to its power-up state. DECSR lets
	//applications know the exact state of the terminal before any attempted
	//operations. You can use DECSR to guarantee the terminal state for secure
	//connections. DECSR is similar to RIS, but does not perform a disconnect from
	//the host.
	//
	//
	//
	//Format:
	//	CSI Pr +  p
	//	9B  3n 2B 70
	//

	DECSSCLS, SetScrollSpeed AnsiEscapeType = iota, iota
	//Set Scroll Speed (DECSSCLS)
	//Select how fast lines appear on the screen.
	//
	//This is a user preference feature. If the User Features Locked is enabled, then
	//the scroll speed cannot be changed by this control function.
	//
	//The escape sequence DECSCLM can change the scroll speed between Smooth 2
	//and Jump scroll.
	//
	//Format:
	//	CSI Ps SP p
	//	9B  3n 20 70
	//

	DECSSDT, SelectStatusDisplayLineType AnsiEscapeType = iota, iota
	//Select Status Display (Line) Type (DECSSDT)
	//This control function lets the host select the type of status line displayed.
	//
	//
	//
	//Format:
	//	CSI Ps $  ~
	//	9B  3n 24 7E
	//
	//Parameters:
	//	0- Default: Indicator status display
	//
	//Default: Indicator status display

	DECSSL, SelectSetUpLanguage AnsiEscapeType = iota, iota
	//Select Set-Up Language (DECSSL)
	//Select one of several languages for Set-Up display menus.
	//
	//
	//
	//Format:
	//	CSI Ps p
	//	9B  3n 50
	//

	DECST8C, SetTabatEvery8Columns AnsiEscapeType = iota, iota
	//Set Tab at Every 8 Columns (DECST8C)
	//Set a tab stop at every eight columns starting with column 9.
	//
	//Any tab stop setting before this command is executed is cleared automatically.
	//Control function TBC clears the tab stops on the display; HTS sets a horizontal
	//tab stop at the active column.
	//
	//Format:
	//	CSI ?  5  W
	//	9B  3F 35 57
	//

	DECSTBM, SetTopAndBottomMargins AnsiEscapeType = iota, iota
	//Set Top And Bottom Margins (DECSTBM)
	//This control function sets the top and bottom margins for the current page. You
	//cannot perform scrolling outside the margins.
	//
	//
	//
	//Format:
	//	CSI Pt ;  Pb r
	//	9B  3n 3B 3n 72
	//
	//Parameters:
	//	Pt- is the line number for the top margin.
	//Default: Pt = 1.
	//
	//Default: Margins are at the page limits

	DECSTRL, SetTransmitRateLimit AnsiEscapeType = iota, iota
	//Set Transmit Rate Limit (DECSTRL)
	//Limit the rate of character transmission according to the selected rate.
	//
	//When enabled, the terminal limits the rate at which it transmits the answerback,
	//CPR, DA, TSI, and DSR messages, as well as the keyboard keys, and any other
	//characters transmitted from the terminal. All messages and keystrokes are
	//transmitted according to the selected "character per second" rate.
	//
	//You can select different transmit rates for graphic keys and function keys, which
	//usually transmit more than one byte at a time.
	//
	//The transmit rate limit function can be enabled and disabled through the
	//DECXRLM control function. When disabled, all messages and keystrokes are
	//transmitted as fast as possible without any delay between characters.
	//
	//Format:
	//	CSI Ps1 ;  Ps2 "  u
	//	9B  3n  3B 3n  22 75
	//
	//Parameters:
	//	You can select different transmit rates for graphic keys and function keys, which- usually transmit more than one byte at a time.	When enabled, the terminal limits the rate at which it transmits the answerback,- CPR, DA, TSI, and DSR messages, as well as the keyboard keys, and any other
	//characters transmitted from the terminal. All messages and keystrokes are
	//transmitted according to the selected "character per second" rate.	Ps2- indicates the characters per second.

	DECSTR, SoftTerminalReset AnsiEscapeType = iota, iota
	//Soft Terminal Reset (DECSTR)
	//Perform a soft reset to the default values listed in
	//
	//Table 5&#8211;9 lists the terminal's default settings:
	//
	//
	//Table 5&#8211;9 Terminal's Default Settings
	//
	//
	//
	//
	//
	//Mode
	//Mnemonic
	//State after DECSTR
	//
	//
	//
	//
	//Text cursor enable
	//DECTCEM
	//Cursor enabled.
	//
	//
	//Insert/replace
	//IRM
	//Replace mode.
	//
	//
	//Origin
	//DECOM
	//Absolute (cursor origin at upper-left of screen.)
	//
	//
	//Autowrap
	//DECAWM
	//No autowrap.
	//
	//
	//National replacement character set
	//DECNRCM
	//Multinational set.
	//
	//
	//Keyboard action
	//KAM
	//Unlocked.
	//
	//
	//Numeric keypad
	//DECNKM
	//Numeric characters.
	//
	//
	//Cursor keys
	//DECCKM
	//Normal (arrow keys).
	//
	//
	//Set top and bottom margins
	//DECSTBM
	//Top margin = 1; bottom margin = page length.
	//
	//
	//All character sets
	//G0, G1, G2, G3, GL, GR
	//Default settings.
	//
	//
	//Select graphic rendition
	//SGR
	//Normal rendition.
	//
	//
	//Select character attribute
	//DECSCA
	//Normal (erasable by DECSEL and DECSED).
	//
	//
	//Save cursor state
	//DECSC
	//Home position.
	//
	//
	//Assign user preference supplemental set
	//DECAUPSS
	//Set selected in Set-Up.
	//
	//
	//Select active status display
	//DECSASD
	//Main display.
	//
	//
	//Keyboard position mode
	//DECKPM
	//Character codes.
	//
	//
	//Cursor direction
	//DECRLM
	//Reset (Left-to-right), regardless of NVR setting.
	//
	//
	//PC Term mode
	//DECPCTERM
	//Always reset.
	//
	//
	//
	//
	//Format:
	//	CSI !  p
	//	9B  21 70
	//

	DECSWBV, SetWarningBellVolume AnsiEscapeType = iota, iota
	//Set Warning Bell Volume (DECSWBV)
	//Set the warning bell volume.
	//
	//This sequence is used to adjust the warning bell volume (for errors and receipt of
	//Ctrl G).
	//
	//Format:
	//	CSI Ps SP t
	//	9B  3n 20 74
	//

	DECSWL, SingleWidthSingleHeightLine AnsiEscapeType = iota, iota
	//Single-Width, Single-Height Line (DECSWL)
	//DECSWL makes the line with the cursor a single-width, single-height line. This
	//line attribute is the standard for all new lines on the screen.
	//
	//
	//
	//Format:
	//	ESC #  5
	//	1B  23 35
	//

	DECTABSR, TabStopReport AnsiEscapeType = iota, iota
	//Tab Stop Report (DECTABSR)
	//The terminal sends this sequence to the host in response to a request
	//presentation state report (DECRQPSR) sequence. DECTABSR informs the host
	//of the terminal's current tab settings.
	//
	//
	//
	//Format:
	//	DCS 2  $  u  D ... D ST
	//	90  32 24 75 ...     9C
	//
	//Parameters:
	//	This operation is useful for applications that need to temporarily change the- terminal's tab stops. When the application is finished, it can restore the tab
	//stops that were in effect before the application changed them. You use the
	//restore presentation state (DECRSPS) function to restore tab stops. Refer to
	//DECRSPS&#8212;Restore Presentation State for additional information.	D...D- is a data string indicating the column number location of each tab stop.	2- The following is an example of a DECTABSR sequence:	3- DCS 2 $ u 9/ 17/ 25/ 33/ 41/ 49/ 57/ 65/ 73 ST

	DECTCEM, TextCursorEnableMode AnsiEscapeType = iota, iota
	//Text Cursor Enable Mode (DECTCEM)
	//This control function makes the cursor visible or invisible.
	//
	//
	//
	//Format:
	//	CSI ?  2  5  h
	//	9B  3F 32 35 68
	//	CSI ?  2  5  l
	//	9B  3F 32 35 6C
	//

	DECTID, SelectTerminalID AnsiEscapeType = iota, iota
	//Select Terminal ID (DECTID)
	//Select a terminal ID.
	//
	//This sequence selects the Primary DA Response ("Terminal ID") transmitted by
	//the terminal. DECTID has no effect when the terminal is in VT52 mode.
	//
	//The VT510 supports the following DA1 responses:
	//
	//
	//
	//
	//VT100 ID
	//ESC [ ? 1; 2 c
	//
	//
	//VT101 ID
	//ESC [ ? 1; 0 c
	//
	//
	//VT102 ID
	//ESC [ ? 6 c
	//
	//
	//VT220 ID (N.A.)
	//CSI ? 62; 1; 2; 7; 8 c
	//
	//
	//VT220 ID (Intnl)
	//CSI ? 62; 1; 2; 7; 8; 9 c
	//
	//
	//VT320 ID (N.A.)
	//CSI ? 63; 1; 2; 7; 8 c
	//
	//
	//VT320 ID (Intnl)
	//CSI ? 63; 1; 2; 7; 8; 9 c
	//
	//
	//VT420 ID (N.A.)
	//CSI ? 64; 1; 2; 7; 8; 9; 15; 18; 21 c
	//
	//
	//VT420 ID (Intnl)
	//CSI ? 64; 1; 2; 7; 8; 9; 15; 18; 21 c
	//
	//
	//VT510 ID
	//Reference function DA1
	//
	//
	//
	//
	//The default ID is "VT510."
	//
	//Format:
	//	CSI Ps ,  q
	//	9B  3n 2C 71
	//

	DECTME, TerminalModeEmulation AnsiEscapeType = iota, iota
	//Terminal Mode Emulation (DECTME)
	//Select a terminal emulation mode.
	//
	//This sequence allows you to select the terminal emulation mode. After any mode
	//change is made, a soft reset is performed.
	//
	//Notes on DECTME
	//
	//
	//Printer operations are not affected or halted by a change in mode.
	//A soft reset is always performed as a result of a mode change between VT
	//modes.
	//Exception: Entering VT52 mode using DECANM does not cause a soft reset
	//from VT100 mode.
	//DECANM and DECSCL can also change the VT operating modes.
	//
	//
	//Format:
	//	CSI Ps SP ~
	//	9B  3n 20 711
	//

	DECTSR, TerminalStateReport AnsiEscapeType = iota, iota
	//Terminal State Report (DECTSR)
	//Requests and reports the state of the terminal.
	//
	//DECRQTSR and DECTSR requests and reports the state of the terminal.
	//
	//Format:
	//	CSI Ps $  u
	//	9B  3n 24 75
	//
	//Parameters:
	//	Response- DCS 1 $S D . . . D ST
	//D ... D
	//See Device Attributes (DA1, DA2, DA3).

	DECTST, InvokeConfidenceTest AnsiEscapeType = iota, iota
	//Invoke Confidence Test (DECTST)
	//Select tests to be performed.
	//
	//After the first parameter, "4", the parameters each select one test. Several
	//tests may be invoked at once by chaining the parameters together separated by
	//semicolons. The tests are not necessarily executed in the order in which they are
	//entered in the parameter string.
	//
	//"ESC # 8" invokes the Screen Alignment test for the VT510. Additionally, after
	//executing the power-up selftest, the terminal displays either the diagnostic
	//messages in the upper left corner of the screen or the "VT510 OK" message in the
	//center of the screen and within a box. Upon receipt of any character except XON
	//or if the user types a keystroke, the screen is cleared. If the terminal is in local
	//mode, then characters from the host are ignored and the message remains visible
	//even if characters are received from the host. DECTST causes a disconnect;
	//therefore, it should not be used in conjunction with a modem.
	//
	//Format:
	//	CSI 4  ;  Ps ... ;  Ps y
	//	9B  34 3B 3n ... 3B 3n 79
	//

	DECUDK, UserDefinedKeys AnsiEscapeType = iota, iota
	//User Defined Keys (DECUDK)
	//DECUDK downloads definitions for user-defined keys.
	//
	//DCS (9/0) indicates the beginning of a device control string. DCS is an 8-bit C1
	//character. You can use ESC P (1/11 5/0) for a 7-bit environment.
	//
	//ST is the string terminator. ST (9/12) is a C1 8-bit character. You can use ESC \
	//(1/11, 5/12) for a 7-bit environment.
	//
	//General Guidelines When Loading UDKs
	//
	//
	//Clear UDK memory space before loading new definitions.
	//Use a DECUDK string to clear keys without locking them. Then you can use
	//another DECUDK string to redefine the keys and lock them.
	//If you redefine a key, then the old definition is lost. This clears space if the
	//new definition uses less bytes than the old one.
	//There is only one way to unlock UDKs.
	//To unlock a UDK, use Set-Up.
	//When you clear a UDK, the key definition is empty.
	//An invalid hex pair in a DECUDK string stops a UDK sequence.
	//When a load sequence stops (error or other cause), the terminal saves keys
	//already loaded and sends the rest of DECUDK to the screen.
	//You can disable the local function keys by redefining them with DECUDK.
	//DECUDK works in all VT modes except VT52 mode.
	//
	//
	//Examples of DECUDK Device Control Strings
	//
	//The following sequence clears unshifted UDKs:
	//
	//DCS 0 ; 1 ; 1 | ST
	//
	//The following sequence locks unshifted UDKs:
	//
	//DCS 1 ; 0 ; 1 | ST
	//
	//Suppose you want to define the unshifted F20 key to be "PRINT", without clearing
	//or locking any other keys. The first part of your sequence would look like this:
	//
	//DCS 1 ; 1 ; 1 | 3 4 /
	//
	//34 is the code for the F20 key.
	//
	//After the slash character (/) (2/15), you include the definition. The rest of the
	//sequence after the slash character would look like this:
	//
	//5 0 5 2 4 9 4 E 5 4 ST
	//
	//The hex encoding for "PRINT" is as follows:
	//
	//
	//
	//
	//50
	//=
	//P
	//
	//
	//52
	//=
	//R
	//
	//
	//49
	//=
	//I
	//
	//
	//4E
	//=
	//N
	//
	//
	//54
	//=
	//T
	//
	//
	//
	//
	//The ST character (9/12) marks the end of the control string:
	//
	//DCS 1 ; 1 ; 1 | 34 / 50 52 49 4E 54 ST
	//
	//Format:
	//
	//Parameters:
	//	Ps3- is the modifier parameter. Ps3 designates whether the key is shifted or unshifted.	D ... D- are the key definition strings such as:	16- The following sequence locks unshifted UDKs:	19- DCS 1 ; 1 ; 1 | 3 4 /	4- 804 (maximum) - 412 ( F6 ) - 366 ( F7 ) = 26	After the slash character (/) (2/15), you include the definition. The rest of the- sequence after the slash character would look like this:	Programming Tip- If Ps1 is 1, a key load may fail because no memory space is available. The reason
	//for this is as follows:	|- is the final character. The vertical bar (7/12) identifies this control string as a
	//DECUDK.	DCS (9/0) indicates the beginning of a device control string. DCS is an 8-bit C1- character. You can use ESC P (1/11 5/0) for a 7-bit environment.	23- The hex encoding for "PRINT" is as follows:	24- The ST character (9/12) marks the end of the control string:	15- DCS 0 ; 1 ; 1 | ST	Suppose you want to define the unshifted F20 key to be "PRINT", without clearing- or locking any other keys. The first part of your sequence would look like this:	With Ps1 set to 1, keys are cleared and loaded sequentially. If the new definition- for a key is larger than the old one, then you may exceed the 804 byte limit.	6- If Ps2 is 1 and the keys are already locked, then nothing happens.	22- 5 0 5 2 4 9 4 E 5 4 ST	When Ps1 is 1, the terminal only clears the keys you are loading. By using a Ps1- value of 1, you can redefine some keys without redefining them all.	ST is the string terminator. ST (9/12) is a C1 8-bit character. You can use ESC \- (1/11, 5/12) for a 7-bit environment.	For example, suppose F6 contains 412 bytes, F7 contains 366 bytes, and F8- contains 20 bytes. You try to load F8 with 40 bytes, F6 with one byte, and F7
	//with one byte, in that order. This works if all keys are cleared first (Ps1 is 0), but
	//not if keys are cleared one at a time (Ps1 is 1). When you try to load F8 with 40
	//bytes, the load fails because only 26 bytes are free at that time.	14- The following sequence clears unshifted UDKs:	The terminal uses a special lock to prevent or allow the programming of user-defined- keys. You can turn on this lock from Set-Up or from the host (with a
	//DECUDK device control string). The lock affects all programmable keys. When
	//you use the lock, you should follow these guidelines:	17- DCS 1 ; 0 ; 1 | ST	20- 34 is the code for the F20 key.	You include these strings between the final character ( | ) and the string- terminator (ST). Each string consists of a key selector number (Kyn), a string
	//parameter (Stn), a slash (/) (2/15), and a direction (Dir). A semicolon (;) (3/11)
	//separates different strings.	Ps2- is the lock parameter. Pl determines whether the key definitions are locked or
	//unlocked after you load them.

	DECVCCM, VerticalCursorCouplingMode AnsiEscapeType = iota, iota
	//Vertical Cursor-Coupling Mode (DECVCCM)
	//This control function determines whether the user window pans with the cursor
	//when the cursor moves past the top or bottom border of the user window.
	//DECVCCM is only useful when the height of the current user window is smaller
	//than the page. The cursor must stay on the current page.
	//
	//When DECVCCM is set, the cursor is coupled to the display for vertical
	//movement. When the cursor moves past the top or bottom border of the user
	//window, the window pans to keep the cursor in view.
	//
	//If the cursor moves past the top of the display, the user window pans up. New
	//lines appear at the top of the screen, while lines at the bottom move out of view.
	//
	//When DECVCCM is reset, the cursor is uncoupled from the display. If the cursor
	//moves past the top or bottom border of the user window, the cursor disappears.
	//
	//Format:
	//	CSI ?  6  1  h
	//	9B  3F 36 31 68
	//	CSI ?  6  1  l
	//	9B  3F 36 31 6C
	//

	DECXCPR, ExtendedCursorPosition AnsiEscapeType = iota, iota
	//Extended Cursor Position (DECXCPR)
	//The host asks the terminal for the current cursor position, including the current
	//page number.
	//
	//
	//
	//Format:
	//	CSI ?  6  n
	//	9B  3F 36 6E
	//

	DECXRLM, TransmitRateLimiting AnsiEscapeType = iota, iota
	//Transmit Rate Limiting (DECXRLM)
	//Applications can control the transmit rate limiting feature through the
	//DECXRLM control function.
	//
	//
	//
	//Format:
	//	CSI ?  7  3  h
	//	9B  3F 37 33 68
	//	CSI ?  7  3  l
	//	9B  3F 37 33 6C
	//
	//Parameters:
	//	The usual way to disconnect communications is to type Shift F5 ( Shift Break ). The- host system's response to the disconnect signal depends on the system and the
	//software.	When the terminal receives XOFF from the printer, the terminal stops sending- data. The terminal starts sending data again when it receives an XON, or when
	//a clear comm operation is performed.	Any of the following conditions will disconnect the connection to the host system- in VT mode:	Using C1 Control Characters- Using an 8-bit setting for the printer port implies the use of 8-bit C1 control
	//characters. Using a 7-bit setting implies the use of the 7-bit ESC form of C1
	//control characters. You select the setting by using the data bits/parity feature
	//in the Printer Set-Up screen.	Terminal-to-Printer Data Flow Control- The terminal sends only data characters to the printer. The terminal does not
	//send XON and XOFF characters. The terminal recognizes only XON and XOFF
	//characters from the printer. Any other characters from the printer are ignored.	Modem Connection and Disconnections- When the terminal makes a connection to the host system through a modem,
	//the terminal performs the following operations to ensure it is ready to send and
	//receive.
	//
	//Default: Unlimited

	DL, DeleteLine AnsiEscapeType = iota, iota
	//Delete Line (DL)
	//This control function deletes one or more lines in the scrolling region, starting
	//with the line that has the cursor.
	//
	//As lines are deleted, lines below the cursor and in the scrolling region move up.
	//The terminal adds blank lines with no visual character attributes at the bottom
	//of the scrolling region. If Pn is greater than the number of lines remaining on the
	//page, DL deletes only the remaining lines. DL has no effect outside the scrolling
	//margins.
	//
	//Format:
	//	CSI Pn M
	//	9B  3n 4D
	//

	DSR, DeviceStatusReports AnsiEscapeType = iota, iota
	//Device Status Reports (DSR)
	//The host computer and terminal exchange DSR sequences to provide the host
	//with the operating status of the following features:
	//
	//There is a different DSR request for each feature. The following sections describe
	//the possible DSR reports. If the terminal is in printer controller mode, then
	//the printer receives the DSR request. The printer can respond through the
	//bidirectional printer port.
	//
	//Format:
	//	CSI Ps n
	//	9B  3n 6E
	//	CSI ?  Ps n
	//	9B  3F 3n 6E
	//
	//Parameters:
	//	Ps- indicates the type of DSR requested. See the following individual DSR reports for
	//specific parameters within each report.

	ECH, EraseCharacter AnsiEscapeType = iota, iota
	//Erase Character (ECH)
	//This control function erases one or more characters, from the cursor position to
	//the right. ECH clears character attributes from erased character positions. ECH
	//works inside or outside the scrolling margins.
	//
	//
	//
	//Format:
	//	CSI Pn X
	//	9B  3n 58
	//

	ED, EraseDisplay AnsiEscapeType = iota, iota
	//Erase Display (ED)
	//This control function erases characters from part or all of the display. When you
	//erase complete lines, they become single-height, single-width lines, with all visual
	//character attributes cleared. ED works inside or outside the scrolling margins.
	//
	//
	//
	//Format:
	//	CSI Ps J
	//	9B  3n 4A
	//

	EL, EraseLine AnsiEscapeType = iota, iota
	//Erase Line (EL)
	//This control function erases characters on the line that has the cursor. EL clears
	//all character attributes from erased character positions. EL works inside or
	//outside the scrolling margins.
	//
	//
	//
	//Format:
	//	CSI Ps K
	//	9B  3n 4B
	//

	HPA, HorizontalPositionAbsolute AnsiEscapeType = iota, iota
	//Horizontal Position Absolute (HPA)
	//Inquire as to the amount of free memory for programmable key operations.
	//
	//HPA causes the active position to be moved to the n-th horizontal position of
	//the active line. If an attempt is made to move the active position past the last
	//position on the line, then the active position stops at the last position on the line.
	//
	//Format:
	//	CSI Pn `
	//	9B  3n 60
	//

	HPR, HorizontalPositionRelative AnsiEscapeType = iota, iota
	//Horizontal Position Relative (HPR)
	//Inquire as to the amount of free memory for programmable key operations.
	//
	//HPR causes the active position to be moved to the n-th following horizontal
	//position of the active line. If an attempt is made to move the active position past
	//the last position on the line, then the active position stops at the last position on
	//the line.
	//
	//Format:
	//	CSI Pn a
	//	9B  3n 61
	//

	HTS, HorizontalTabSet AnsiEscapeType = iota, iota
	//Horizontal Tab Set (HTS)
	//HTS sets a horizontal tab stop at the column position indicated by the value of
	//the active column when the terminal receives an HTS.
	//
	//Executing an HTS does not effect the other horizontal tab stop settings.
	//
	//Format:
	//	HTS
	//	88
	//	ESC H
	//	1B  48
	//

	HVP, HorizontalandVerticalPosition AnsiEscapeType = iota, iota
	//Horizontal and Vertical Position (HVP)
	//This control function works the same as the cursor position (CUP) function. New
	//applications should use CUP instead of HVP. HVP is provided for compatibility
	//with earlier VT products.
	//
	//
	//
	//Format:
	//	CSI f
	//	9B  66
	//	CSI Pl ;  Pc f
	//	9B  3n 3B 3n 66
	//

	ICH, InsertCharacter AnsiEscapeType = iota, iota
	//Insert Character (ICH)
	//This control function inserts one or more space (SP) characters starting at the
	//cursor position.
	//
	//The ICH sequence inserts Pn blank characters with the normal character
	//attribute. The cursor remains at the beginning of the blank characters. Text
	//between the cursor and right margin moves to the right. Characters scrolled past
	//the right margin are lost. ICH has no effect outside the scrolling margins.
	//
	//Format:
	//	CSI Pn @
	//	9B  3n 40
	//
	//Parameters:
	//	Pn- is the number of characters to insert.
	//Default: Pn = 1.

	IL, InsertLine AnsiEscapeType = iota, iota
	//Insert Line (IL)
	//This control function inserts one or more blank lines, starting at the cursor.
	//
	//As lines are inserted, lines below the cursor and in the scrolling region move
	//down. Lines scrolled off the page are lost. IL has no effect outside the page
	//margins.
	//
	//Format:
	//	CSI Pn L
	//	9B  3n 4C
	//

	IND, Index AnsiEscapeType = iota, iota
	//Index (IND)
	//IND moves the cursor down one line in the same column. If the cursor is at the
	//bottom margin, then the screen performs a scroll-up.
	//
	//
	//
	//Format:
	//	ESC D
	//	1B  44
	//

	RI, ReverseIndex AnsiEscapeType = iota, iota
	//ReverseIndex (RI)
	//Move the active position to the same horizontal position on the preceding line. If the active position is at the top margin, a scroll down is performed
	//
	//
	//
	//Format:
	//	ESC M
	//	1B  4D
	//

	IRM, InsertReplaceMode AnsiEscapeType = iota, iota
	//Insert/Replace Mode (IRM)
	//This control function selects how the terminal adds characters to page memory.
	//The terminal always adds new characters at the cursor position.
	//
	//If IRM mode is set, then new characters move characters in page memory to the
	//right. Characters moved past the page's right border are lost.
	//
	//If IRM mode is reset, then new characters replace the character at the cursor
	//position.
	//
	//Format:
	//	CSI 4  h
	//	9B  34 68
	//	CSI 4  l
	//	9B  34 6C
	//

	KAM, KeyboardActionMode AnsiEscapeType = iota, iota
	//Keyboard Action Mode (KAM)
	//This control function locks or unlocks the keyboard.
	//
	//If KAM is set, then the keyboard cannot send characters to the host. The Wait
	//indicator appears on the keyboard indicator line at the bottom of the screen. The
	//terminal ignores all keystrokes that send characters to the host. KAM does not
	//affect the F3 (Set-Up) or F4 (Session) keys.
	//
	//If KAM is reset, then the terminal unlocks the keyboard. The keyboard can send
	//characters to the host.
	//
	//Format:
	//	CSI 2  h
	//	9B  32 68
	//	CSI 2  l
	//	9B  32 6C
	//

	LNM, LineFeedNewLineMode AnsiEscapeType = iota, iota
	//Line Feed/New Line Mode (LNM)
	//This control function selects the characters sent to the host when you press the
	//
	//
	//If LNM is set, then the cursor moves to the first column on the next line when
	//the terminal receives an LF, FF, or VT character. When you press Return, the
	//terminal sends both a carriage return (CR) and line feed (LF).
	//
	//If LNM is reset, then the cursor moves to the current column on the next line
	//when the terminal receives an LF, FF, or VT character. When you press Return,
	//the terminal sends only a carriage return (CR) character.
	//
	//Note on LNM
	//
	//When the auxiliary keypad is in keypad numeric mode (DECKPNM), the Enter
	//key sends the same characters as the Return key.
	//
	//Format:
	//	CSI 2  0  h
	//	9B  32 30 68
	//	CSI 2  0  l
	//	9B  32 30 6C
	//

	LS, LockingShift AnsiEscapeType = iota, iota
	//Locking Shift (LS)
	//When you use a locking shift, the character set remains in GL or GR until you
	//use another locking shift.
	//
	//
	//
	//Format:
	//

	MC, MediaCopy AnsiEscapeType = iota, iota
	//Media Copy (MC)
	//MC is the control sequence that enables the terminal to control all print
	//functions. There are two variations—ANSI standard and VT mode.
	//
	//
	//
	//Format:
	//	CSI Pn i
	//	9B  3n 69
	//	CSI ?  Pn i
	//	9B  3F 3n 69
	//
	//Parameters:
	//	Pn (VT mode)- indicates the following VT mode print functions:

	NEL, NextLine AnsiEscapeType = iota, iota
	//Next Line (NEL)
	//Moves cursor to first position on next line. If cursor is at bottom margin, then
	//screen performs a scroll-up.
	//
	//
	//
	//Format:
	//	ESC E
	//	1B  45
	//

	NP, NextPage AnsiEscapeType = iota, iota
	//Next Page (NP)
	//This control function moves the cursor forward to the home position on one of
	//the following pages in page memory. If there is only one page, then the terminal
	//ignores NP.
	//
	//
	//
	//Format:
	//	CSI Pn U
	//	9B  3n 55
	//
	//Parameters:
	//	Pn- indicates how many pages to move the cursor forward.
	//Default: Pn = 0.
	//
	//Default: Move to the next page

	PPA, PagePositionAbsolute AnsiEscapeType = iota, iota
	//Page Position Absolute (PPA)
	//This control function can move the cursor to the corresponding row and column
	//on any page in page memory. You select the page by its number. If there is only
	//one page, then the terminal ignores PPA.
	//
	//
	//
	//Format:
	//	CSI Pn SP P
	//	9B  3n 20 50
	//

	PPB, PagePositionBackward AnsiEscapeType = iota, iota
	//Page Position Backward (PPB)
	//This control function moves the cursor backward to the corresponding row and
	//column on one of the preceding pages in page memory. If there is only one page,
	//then the terminal ignores PPB.
	//
	//
	//
	//Format:
	//	CSI Pn SP R
	//	9B  3n 20 52
	//

	PPR, PagePositionRelative AnsiEscapeType = iota, iota
	//Page Position Relative (PPR)
	//This control function moves the cursor forward to the corresponding row and
	//column on one of the following pages in page memory. If there is only one page,
	//then the terminal ignores PPR.
	//
	//
	//
	//Format:
	//	CSI Pn SP Q
	//	9B  3n 20 51
	//

	PP, PrecedingPage AnsiEscapeType = iota, iota
	//Preceding Page (PP)
	//This control function moves the cursor backward to the home position on one of
	//the preceding pages in page memory. If there is only one page, then the terminal
	//ignores PP.
	//
	//
	//
	//Format:
	//	CSI Pn V
	//	9B  3n 56
	//
	//Parameters:
	//	Pn- indicates how many pages to move the cursor backward.
	//Default: Pn = 0.
	//
	//Default: Move to the preceding page

	RIS, ResettoInitialState AnsiEscapeType = iota, iota
	//Reset to Initial State (RIS)
	//This control function causes a nonvolatile memory (NVR) recall to occur. RIS
	//replaces all set-up features with their saved settings.
	//
	//
	//
	//Format:
	//	ESC c
	//	1B  63
	//

	RM, ResetMode AnsiEscapeType = iota, iota
	//Reset Mode (RM)
	//There are two formats of this control function. You use the ANSI format to reset
	//one or more ANSI modes. You use the DEC format to reset one or more DEC
	//modes. You cannot reset ANSI and DEC modes with the same RM sequence.
	//
	//
	//
	//Format:
	//	CSI ?  Pd ;  ... ;  Pd l
	//	9B  3F 3n 3B ... 3B 3n 6C
	//
	//Parameters:
	//	The following sequence resets (Hebrew) keyboard mapping (DECHEBM) and- Hebrew encoding mode (DECHEM):	0- DEC Modes	2- CSI ? 34; 36 l	34 indicates (Hebrew) keyboard mapping.- 36 indicates Hebrew encoding mode.

	S7C1T, SendC1ControlCharactertoHost AnsiEscapeType = iota, iota
	//Send C1 Control Character to Host (S7C1T)
	//The VT510 can send C1 control characters to the host as single 8-bit characters
	//or as 7-bit escape sequences. You should select the format that matches the
	//operating level you are using.
	//
	//This sequence changes the terminal mode as follows:
	//
	//
	//
	//
	//
	//
	//Mode Before
	//Mode After
	//
	//
	//
	//
	//VT Level 4 mode, 8-bit controls
	//VT Level 4 mode, 7-bit controls.
	//
	//
	//VT Level 4 mode, 7-bit controls
	//Same. Terminal ignores sequence.
	//
	//
	//VT Level 1 or VT52 mode, 7-bit controls
	//Same. Terminal ignores sequence.
	//
	//
	//
	//
	//Format:
	//	ESC SP F
	//	1B  20 47
	//

	S8C1T, SendC1ControlCharactertotheHost AnsiEscapeType = iota, iota
	//Send C1 Control Character to the Host (S8C1T)
	//The following sequence causes the terminal to send C1 control characters to the
	//host as single 8-bit characters:
	//
	//This sequence changes the terminal mode as follows:
	//
	//
	//
	//
	//
	//
	//Mode Before
	//Mode After
	//
	//
	//
	//
	//VT Level 4 mode, 8-bit controls
	//Same. Terminal ignores sequence.
	//
	//
	//VT Level 4 mode, 7-bit controls
	//VT Level 4 mode, 8-bit controls.
	//
	//
	//VT Level 1 mode
	//Same. Terminal ignores sequence.
	//
	//
	//
	//
	//Format:
	//	ESC SP G
	//	1B  20 46
	//

	SCODFK, DefineFunctionKey AnsiEscapeType = iota, iota
	//Define Function Key (SCODFK)
	//Programs function key to send a defined string in SCO Console mode.
	//
	//The first character after the ASCII character representing a function key becomes
	//the delimiter. It looks for an identical character as the second and final delimiter.
	//If string is too long and no memory is available, then the command string
	//is aborted and remaining characters are displayed on screen. The character
	//becomes the final character. All the following characters are displayed on the
	//screen.
	//
	//Example:
	//
	//Executing "ESC Q 0 'abcdefghij'klmnopq" when 100 bytes of memory is
	//available defines the string "abcdefghij" into F1 function key and displays
	//"klmnopq" on the screen.
	//
	//If you execute the same sequence when only a 4 byte string is allowed, then the
	//whole sequence is aborted.
	//
	//A "^" character causes any following character to subtract 32 from its ASCII
	//value. For example, "^e" in the string sends "E" when the key is pressed.
	//
	//Any code in the 00-7F region can be defined. An 8-bit code entered is stripped of
	//its eighth bit and defined as a corresponding 7-bit code.
	//
	//For example, executing ESCQ0'F1KEY' defines string F1KEY for function key F1;
	//ESC1aF2KEYa defines string F2key for F2.
	//
	//The maximum string length for a defined key is 255 characters.
	//
	//Format:
	//	ESC Q  Fn  string
	//	1B  51 ... ...
	//
	//Parameters:
	//	Any code in the 00-7F region can be defined. An 8-bit code entered is stripped of- its eighth bit and defined as a corresponding 7-bit code.	If you execute the same sequence when only a 4 byte string is allowed, then the- whole sequence is aborted.	For example, executing ESCQ0'F1KEY' defines string F1KEY for function key F1;- ESC1aF2KEYa defines string F2key for F2.	String- is the programmed key definition which is enveloped by two characters as the
	//delimiters.	A "^" character causes any following character to subtract 32 from its ASCII- value. For example, "^e" in the string sends "E" when the key is pressed.	2- Example:	The first character after the ASCII character representing a function key becomes- the delimiter. It looks for an identical character as the second and final delimiter.
	//If string is too long and no memory is available, then the command string
	//is aborted and remaining characters are displayed on screen. The character
	//becomes the final character. All the following characters are displayed on the
	//screen.

	SCORC, RestoreSavedCursorPosition AnsiEscapeType = iota, iota
	//Restore Saved Cursor Position (SCORC)
	//Moves cursor to the position saved by save cursor command in SCO console mode.
	//
	//This command acts the same as the DECRC command, except that the cursor
	//stays at the same page instead of moving to a page where the cursor was saved.
	//
	//Format:
	//	CSI u
	//	9B  75
	//

	SCOSC, SaveCurrentCursorPosition AnsiEscapeType = iota, iota
	//Save Current Cursor Position (SCOSC)
	//Saves current cursor position for SCO console mode.
	//
	//This command acts the same as the DECSC command, except that the page
	//number where the cursor is located is not saved as a result of executing the
	//command.
	//
	//Format:
	//	CSI s
	//	9B  73
	//

	SCS, SelectCharacterSet AnsiEscapeType = iota, iota
	//Select Character Set (SCS)
	//Designate character sets to G-sets.
	//
	//
	//
	//Format:
	//	ESC I   Dscs
	//	1B  ... ...
	//

	SD, PanUp AnsiEscapeType = iota, iota
	//Pan Up (SD)
	//This control function moves the user window up a specified number of lines in
	//page memory.
	//
	//
	//
	//Format:
	//	CSI Pn T
	//	9B  3n 54
	//

	SGR, SelectGraphicRendition AnsiEscapeType = iota, iota
	//Select Graphic Rendition (SGR)
	//This control function selects one or more character attributes at the same time.
	//
	//
	//
	//Format:
	//	CSI Ps ;  Ps ... m
	//	9B  3n 3B 3n ... 6D
	//
	//Parameters:
	//	Commands "CSI 10-12 m" affect only the Hex 00-7F portion of the display- character set. The hex 80-FF region of the display character set is left intact.	When "ESC 11 m" is executed, the display character set is loaded with codes in- the Hex 00 to 7F region of a PC character set. PC characters whose code values
	//are less than 1F can be displayed through this sequence except 1B (ESC) and
	//11(DC1), 13(DC3) when XON/XOFF is enabled. 1B is always executed as an
	//ESC to allow the application to execute the command to go back to the default
	//character set. Hex 11 and 13 can be displayed only when XON/XOFF is disabled.
	//This command does not work when the ISO/ANSI character set is selected.	When you select more than one attribute in an SGR sequence, then they are- executed in order. For example, you can use the following sequence to display
	//text that is bold, blinking, and underlined:	5- CSI 7 m	4- The following sequence displays the negative image of text:	Ps- is a number representing a certain visual attribute. You can use more than one
	//Ps value to select different character attributes. Table 5&#8211;16 lists Ps values and
	//the attributes they select.	Command "ESC 12 m" toggles the high bit of the current 8-bit character set. All- the characters in Hex 80-FF region can be displayed as 7-bit codes except 9B
	//(ESC) and 91(DC1), 93(DC3) when XON/XOFF is enabled. After the command is
	//executed, 1B is executed as an ESC. Hex 11 and 13 can be displayed only when
	//XON/XOFF is disabled.	1- Default: Ps = 0 (clears all attributes).	The ASCII character set with control codes residing in Hex 00 to 1F region is- the default 7-bit display character set. This is true regardless of the ISO/ANSI
	//or PC character set. When in an ISO/ANSI character set, issuing "CSI 10 m" is
	//equivalent to "designating and invoking ASCII to G0 and GL."	3- CSI 0 ; 1 ; 5 ; 4 m
	//
	//Default: Clear all attributes

	SM, SetMode AnsiEscapeType = iota, iota
	//Set Mode (SM)
	//This control function has two formats. You use the ANSI format to set one or
	//more ANSI modes. You use the DEC format to set one or more DEC modes. You
	//
	//
	//
	//
	//Format:
	//	CSI ?  Pd ;  ... Pd h
	//	9B  3F 3n 3B ... 3n 68
	//
	//Parameters:
	//	34 indicates (Hebrew) keyboard mapping.- 36 indicates Hebrew encoding mode.	0- DEC Modes	2- CSI ? 34; 36 h	The following sequence sets (Hebrew) keyboard mapping (DECHEBM) and- Hebrew encoding mode (DECHEM):

	SRM, LocalEchoSendReceiveMode AnsiEscapeType = iota, iota
	//Local Echo: Send/Receive Mode (SRM)
	//This control function turns local echo on or off. When local echo is on, the
	//terminal sends keyboard characters to the screen. The host does not have to send
	//(echo) the characters back to the terminal display. When local echo is off, the
	//terminal only sends characters to the host. It is up to the host to echo characters
	//back to the screen.
	//
	//When the SRM function is set, the terminal sends keyboard characters to the
	//host only. The host can echo the characters back to the screen.
	//
	//When the SRM function is reset, the terminal sends keyboard characters to
	//the host and to the screen. The host does have to echo characters back to the
	//terminal.
	//
	//Format:
	//	CSI 1  2  h
	//	9B  31 32 68
	//	CSI 1  2  l
	//	9B  31 32 6C
	//

	SS, SingleShifts AnsiEscapeType = iota, iota
	//Single Shifts (SS)
	//You use a single shift when you want to display the next character from a
	//different character set. A single shift maps the G2 or G3 set into GL. The
	//character set is active for only one character, then the terminal returns to the
	//previous character set in GL.
	//
	//
	//
	//Format:
	//
	//Parameters:
	//	Suppose the ASCII character set is in GL. You want to display the alpha- character from the DEC Technical character set, already designated as G3.
	//You do not want to replace the ASCII set just to display one character. Instead,
	//you can use single shift 3 to temporarily map the DEC Technical set (G3) into GL.

	SU, PanDown AnsiEscapeType = iota, iota
	//Pan Down (SU)
	//This control function moves the user window down a specified number of lines in
	//page memory.
	//
	//
	//
	//Format:
	//	CSI Pn S
	//	9B  3n 53
	//

	TBC, TabClear AnsiEscapeType = iota, iota
	//Tab Clear (TBC)
	//This control function clears tab stops.
	//
	//
	//
	//Format:
	//	CSI Ps g
	//	9B  3n 67
	//

	VPA, VerticalLinePositionAbsolute AnsiEscapeType = iota, iota
	//Vertical Line Position Absolute (VPA)
	//VPA inquires as to the amount of free memory for programmable key operations.
	//
	//VPA causes the active position to be moved to the corresponding horizontal
	//position.
	//
	//The default value is 1.
	//
	//Move cursor to line Pn. VPA causes the active position to be moved to the
	//corresponding horizontal position at vertical position Pn. If an attempt is made to
	//move the active position below the last line, then the active position stops on the
	//last line.
	//
	//Format:
	//	CSI Pn d
	//	9B  3n 64
	//

	VPR, VerticalPositionRelative AnsiEscapeType = iota, iota
	//Vertical Position Relative (VPR)
	//VPR inquires as to the amount of free memory for programmable key operations.
	//
	//VPR causes the active position to be moved to the corresponding horizontal
	//position.
	//
	//This command causes the active position to be moved to the corresponding
	//horizontal position at n-th following vertical position. If an attempt is made to
	//move the active position below the last line, the active position stops at the last
	//line.
	//
	//Format:
	//	CSI Pn e
	//	9B  3n 65
	//
)
